<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="计算机 比特币 互联网金融 IFWallet" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="区块链爱好者，互联网从业者">
<meta name="keywords" content="bibodeng, blockchain, bitcoin, bitcoin cash, life, programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="bibodeng">
<meta property="og:url" content="https://bibodeng.github.io/page/7/index.html">
<meta property="og:site_name" content="bibodeng">
<meta property="og:description" content="区块链爱好者，互联网从业者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bibodeng">
<meta name="twitter:description" content="区块链爱好者，互联网从业者">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> bibodeng </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">bibodeng</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Think By My Mind</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/12/02/简析js设计模式接口基础/" itemprop="url">
                  简析js设计模式接口基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-12-02T19:56:41+08:00" content="2013-12-02">
              2013-12-02
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/12/02/简析js设计模式接口基础/" class="leancloud_visitors" data-flag-title="简析js设计模式接口基础">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简析js设计模式接口基础"><a href="#简析js设计模式接口基础" class="headerlink" title="简析js设计模式接口基础"></a>简析js设计模式接口基础</h1><p>by bibodeng 2013-12-02</p>
<p>想起要对js设计模式中一些基础的代码做一个简单分析，让自己印象更加深刻。例如接口，继承，闭包等等，方便以后要的时候直接拿来。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口，学过Java的同学肯定知道，声明一个接口，里面有若干方法，而一个类负责实现（<code>implements</code>）它，语言本身的机制会强制该类必须实现接口中声明的所有方法，否则就会报错。实现接口的目的是为了提供一组通用的叫法，让不同的对象实现它。很常见的就是在组合模式中，父元素和子元素都实现了相同的接口，从而可以很直接地将请求从任意一层传递下去。总之，接口能够提供一个通用的方法库，也要保证各类都有实现所有方法。接口在js中的实现方法有三种： </p>
<ul>
<li>注释法 （就是用注释来说明）</li>
<li>属性检查法</li>
<li>duck type(会呱呱叫的都是鸭子)</li>
</ul>
<h2 id="属性检查法"><a href="#属性检查法" class="headerlink" title="属性检查法"></a>属性检查法</h2><p>注释法就不详细看了，因为它就是用注释声明一些接口，而不做任何检查，完全靠人工检查是否实现了相应的方法。而属性检查法，相对来讲严格一点，它将一组接口的名字都放入一个数组中。</p>
<pre><code>// 这是后面组合模式表单的一个例子
var ClassA = function(){
    // 声称自己有一组接口
    this.interfaces = [&apos;Composite&apos;, &apos;FormItem&apos;];
}
</code></pre><p>为了检查是否实现了相应的接口，就检查该类的实例是否具有某个接口，这个某个接口是作为字符串传入需要检查的接口名。</p>
<pre><code>// 模仿implements
function implements(obj){
    // 对传入的参数（接口名进行检查）
    for (var i=1; i &lt; arguments.length; i++)
    {
        var interfaceName = arguments[i];
        var interfaceFound = false;
        // 检查声称的接口 比对两个数组需要两个循环
        for (var j=0; j&lt;obj.interfaces.length; j++){
            if (obj.interfaces[j] == interfaceName){
                interfaceFound = true;  // 接口j找到了
                break;
            }
        }
        // 只要有一个接口没有实现
        if(!interfaceFound){
            throw {
                name: &apos;interface error&apos;,
                msg: &apos;some interfaces not found in obj&apos;
            }
            return false;
        }
    }
    return true;    // 全部通过检查
}

// 调用方法
if (!implements(obj, &apos;Composite&apos;, &apos;FormItem&apos;)){
    ...
}
</code></pre><p>这次只是把这些接口名都放到一个数组中，但是还是没有确保在<code>ClassA</code>中实现接口中的方法（还是以注释的方式说明）。在实践中看起来也没啥用处。我们需要的是真正能够检查对象的方法，我们瞬间想到了<code>for (var index in obj)</code> 对每个方法进行检查。而我们的接口，也应该放在一个像这样的对象中，它能够维护接口的名字和各种方法名。</p>
<pre><code>{
    interfaceName: &apos;Composite&apos;,
    methods: [&apos;add&apos;, &apos;remove&apos;, &apos;getChild&apos;]
}
</code></pre><p>初步的思想是有了，但是实现要灵活，能够生成一个如上的对象。<code>duck typing</code>就是这样做的：</p>
<h2 id="鸭式辨形"><a href="#鸭式辨形" class="headerlink" title="鸭式辨形"></a>鸭式辨形</h2><p>会呱呱叫的两只脚走路的会游泳的就是鸭子。我们生活中常常是一个经验主义者，通过这样的方法来判断事物。所有，理解起来也不是很难：</p>
<pre><code>// 接口对象
var Composite = new Interface(&apos;Composite&apos;, [&apos;add&apos;, &apos;remove&apos;, &apos;getChild&apos;]);

// 要得到上面的对象，我们写一个构造函数专门用来新建接口对象
function Interface(interfaceName, methods){
    this.interfaceName = interfaceName;
    this.methods = methods;
    // new操作将返回this
}

// 如果要严密一点，就需要检查参数的个数和类型
</code></pre><p>这次就不用注释了，而且代码很明了。声明了一个接口对象Composite,它的名字叫做<code>Composite</code>,具有<code>add</code>，<code>remove</code>，<code>getChild</code>三个方法。那么如何声明实现了该接口，并且用什么来确保对象实现了我们接口声明的方法呢？</p>
<p>这次都不用声明实现了该接口，只要实现了相应的方法就是实现了该接口。所以不用显式地声明<code>implements</code>了什么。而是在某个方法之前用<code>ensureImplements</code>来检查。至于设计成<code>Interface</code>的内置方法，还是普通函数，都是可以的。</p>
<pre><code>// obj, interf1, interf2
Interface.ensureImplements = function(obj){
    if (arguments.length &lt; 2){
        throw new Error(&quot;arguments require for at least 2&quot;);
    }

    // 依次检查 这次的参数是interface实例，不再是字符串
    // 而一个字符串数组也变成了真正的对象的属性
    for (var i=1; i&lt;arguments.length; i++){
        var interface = arguments[i];
        // 严格的类型检查
        if (interface.constructor !== Interface){
            throw new Error(&quot;argument &quot; + i + &quot; is not the instance of Interface Class&quot;);
        }

        for (var j=0; j&lt;interface.methods.length; j++){
            var method = interface.methods[j];
            if (!obj[method] || typeof obj[method] !== &apos;function&apos;){
                throw new Error(&quot;ensureImplements error: method&quot; + interface.methods[j] +
                    &apos; in interface &apos;+ interface.interfaceName + &apos; was not found.&apos;);
            }
        }
    }
}

// 调用示例
function foo(formObj){
    // 不满足条件回报错
    Interface.ensureImplements(formObj, Composite, FormItem);

    // 使用接口中的方法
    formObj.remove();
    ...
}
</code></pre><p>主要就是实现一个<code>Interface</code>类，供生成实例，也提供一个<code>ensureImplement</code>方法。只要引入了这个类，就可以使用new一个Interface，然后检查的方式严格要求类实现了接口中的方法。但是我总觉得少了一步，就是声明一下某个类实现了某个接口。当然也可以用数组将所实现的接口都存一个对应的应用，如<code>{&#39;Composite&#39;: Composite}</code>。但是这样看起来就不像是鸭式辨型了。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/29/【书】读《js设计模式》/" itemprop="url">
                  【书】读《js设计模式》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-29T11:17:51+08:00" content="2013-11-29">
              2013-11-29
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/29/【书】读《js设计模式》/" class="leancloud_visitors" data-flag-title="【书】读《js设计模式》">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="读《js设计模式》"><a href="#读《js设计模式》" class="headerlink" title="读《js设计模式》"></a>读《js设计模式》</h1><p>by bibodeng 2013-11-29</p>
<h2 id="迫切的需求"><a href="#迫切的需求" class="headerlink" title="迫切的需求"></a>迫切的需求</h2><p>接触前端大概一年了，由于许多深入的东西都不懂，所以做不出高级的东西。对于稍微复杂一点的需求，都觉得难以下手。于是意识到了要学学设计模式了，所以就翻开（准确来说是点开了）这本《javascript设计模式》。由于有了js的基础，在读了《js编程精粹》之后，对于这门语言有了喜爱和习惯，于是这本书读起来也没有太大压力。我在读的过程中，曾对照自己之前做过的一些页面功能，发现书中的模式很多是可以应用进去的，并且写出来的代码已经优雅很多，由于少了杂乱，故而维护和扩展就容易了，代码出错的几率降低很多。</p>
<p>现在读完第一遍，我克服了自己敲代码欲望，或者说是因为懒惰而没有敲代码。过了一遍，对于设计模式总算能够几个了。装饰器，命令，组合，代理等等，像小学生一样能够掰着手指数出来了。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对于每一种模式，都有详细的例子帮助理解，首先各种模式的基础，首先是js的面向对象（基于对象）。声明一些单体或者是类，将数据和方法都封装起来，更进一步的，使用接口确保对象实现了某些方法。闭包的方法对对象的封装，真正做到了内外的隔离，普通的使用下划线命名方法来标示私用方法，但是闭包中只有返回的对象才能访问闭包里面的方法。这就像是一个孩子打娘胎里面出来，出来以后还能用娘胎里面的资源，有点不可思议，但这却是非常有用。闭包能做到这样是因为其上下文是词法上下文，对象方法将在其定义的地方运行。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>oop的三要素是 封装，继承，多态，封装起来的东西要能重用，就必须用到继承，而继承又有很多种，经典的是clone，另外一种是共用父对象，然后按需修改。clone需要消耗更多资源，而共用的话虽然消耗资源少容易引起冲突。</p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/2dce8da4d2a3c7480901c758f3c40c5a2013112902543112793.png" alt="js设计模式思维导图"></p>
<p>有兴趣的话，点这里<a href="http://vdisk.weibo.com/s/cNgTU_6cNWzK" target="_blank" rel="noopener">下载</a>。</p>
<h3 id="详细的导图"><a href="#详细的导图" class="headerlink" title="详细的导图"></a>详细的导图</h3><p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/cb5a6107522bf8d479788248cb01a0722013112902543526907.png" alt="js设计模式思维导图-大"></p>
<p>有兴趣的话，点这里<a href="http://vdisk.weibo.com/s/cNgTU_6cNWzU" target="_blank" rel="noopener">下载</a>。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>后续将对一些具体的模式做笔记，通过使用代码的方式来巩固对于模式的认识。至少知道这些模式之后，对于一些功能的实现心里就有底了，这很大程度得益于本书的例子很丰富： 图书馆管理，rss阅读器，tips组件，表单组件，远程代理等等例子非常生动，严重建议搞web前端的同学读读这本经典。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/28/【书】人生是一场修行——读《少有人走的路》/" itemprop="url">
                  【书】人生是一场修行——读《少有人走的路》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-28T21:20:20+08:00" content="2013-11-28">
              2013-11-28
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/28/【书】人生是一场修行——读《少有人走的路》/" class="leancloud_visitors" data-flag-title="【书】人生是一场修行——读《少有人走的路》">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="人生是一场修行——读《少有人走的路》"><a href="#人生是一场修行——读《少有人走的路》" class="headerlink" title="人生是一场修行——读《少有人走的路》"></a>人生是一场修行——读《少有人走的路》</h1><p>by bibodeng 2013-11-28</p>
<h2 id="对自己负责"><a href="#对自己负责" class="headerlink" title="对自己负责"></a>对自己负责</h2><p>也许这种文字不太适合放到博客里面去，因为未必有人感兴趣。花几天看完了《少有人走的路》，也许该写写读后感，因为我对于书中的内容有共鸣。都说读书是从书中的世界里面发现自己，从这本书里面我看到了自己的影子。常人掌握控制意识的能力能够做出更加恰当的决策，而探索未知的潜意识更多是心理学家做的事情。</p>
<p>人的意识有多个阶段：</p>
<ul>
<li>婴儿阶段： 自我意识很弱，潜意识和意识高度统一</li>
<li>少年阶段： 意识形成阶段，具备一定自我意识，会遇到意识和潜意识不统一的情况，从而产生迷茫</li>
<li>成年阶段： 具备成熟的意识</li>
</ul>
<p>而我们的提升，是要控制自己的意识，达到潜意识和意识的统一，从而活的更加快乐和幸福。要做到心智的成熟我们需要懂得自律：</p>
<ul>
<li>推迟满足感</li>
<li>承担责任</li>
<li>尊重事实</li>
<li>保持平衡</li>
</ul>
<p>控制我们意识的主要目的就是保持和客观世界和内在潜意识的和谐一致。不得不承认心理的力量，有时强大到能够产生奇迹，这种力量来源于我们的爱和勇气。</p>
<h2 id="人生是一场修行"><a href="#人生是一场修行" class="headerlink" title="人生是一场修行"></a>人生是一场修行</h2><p>人生挺辛苦的，这个是我长大之后体会到的。但是其实也不苦，只是稍微要付出点努力而已。派克认为人的原罪（罪过的根源）是<strong>懒惰</strong>。《追风筝的人》里阿米尔的爸爸说盗窃是一切罪过的根源，杀人是盗窃他人的生存权利。懒惰作为答案会更加深刻一点。大多数人的不幸，除了先天，多数是因为懒惰造成的。正是因为维护正义和促进自身的心智成熟需要付出艰苦卓绝的努力，所以大多数人都很懒。于我自己的影子当中，我也或多或少地察觉到那些贪嗔痴都是因为自己的不够理性，不够有智慧，从而陷入其中的痛苦中。中国的儒家，印度的佛教，欧洲的基督教，都是教导大家心智成熟的，塑造人心内的坚定信念，对世界施以仁爱，正义。当心境做到足够宽广，也就成了圣贤，菩萨。人生是一场修行，很辛苦，但是可以很精彩。</p>
<p>如此说来，世上又有什么难事呢？只要你想，集中精力努力去做，又有什么事情是做不成的。人的聪明才智虽然有限，但是竭尽全力总不见得一无所获。</p>
<h2 id="关于潜意识"><a href="#关于潜意识" class="headerlink" title="关于潜意识"></a>关于潜意识</h2><p>我很小的时候就仿佛体会到那种使命感，不清楚那是潜意识，还是因为阅读所引发出的我对事物和生活的热爱。《少有人走的路》中说潜意识是光明，是上帝的意识。而如果我们自己的意识有了错误，和潜意识不相互吻合，就会产生一些病态，让人痛苦。至于潜意识到底是不是上帝的意识，这很难说。也许大自然的意识是所有人所共享的，领悟它的大门随时为人们打开，里面有对事务的洞见和领悟。那些很成功的人，似乎都有一种使命感，他们或狂热地投入自己钟爱的事业，或在不断的困难中提升自己。不由得想起前段时间李开复采访库彻时说：“我相信有上帝，有神的意识”，而那些能够进入领悟大门的人，似乎都具有了与众不同的见识。其实每个人都有自己的意志，很多时候真的是看你愿意不愿意勇敢去担当这份使命而已，它可能是自己潜意识立下的使命。</p>
<p>很重要的一种触碰到人类智慧的方法是——阅读先哲们留下的经典。听百家讲坛讲《易传》的时候有这种感觉，阅读卢梭的《忏悔录》的时候也有这种感觉（尽管里面什么大道理也没讲）。或许是人类本来就和自然连接在一起，并且潜意识很强大，知道更多我们平常没在意的事情。但是这种爱智慧的传承方法，确实令人对自然感到敬畏，也为先哲们写下的经典深深震撼。独立之人格和自由之思想，我想大概是从书籍里面开始的。一个人开窍，甚至可能因为一件小事或一段文字触动了他的神经，从此以后他便积极向上，走向心智成熟了。</p>
<p>冥冥之中，人与宇宙是相通的。什么时候能够获得心智上的自由，那么便没有哀愁忧虑，取而代之的是悠长的幸福感，是爱。也许，这些东西很虚，但是这确实是某些人的实际感觉，只有勇于探索才能获得更多真知灼见。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/21/重写share2SNS/" itemprop="url">
                  重写share2SNS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-21T10:48:04+08:00" content="2013-11-21">
              2013-11-21
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/21/重写share2SNS/" class="leancloud_visitors" data-flag-title="重写share2SNS">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="重写share2SNS"><a href="#重写share2SNS" class="headerlink" title="重写share2SNS"></a>重写share2SNS</h1><p>by bibodeng 2013-11-20</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，@myunlessor 兄跟我讨论的时候提到我之前用的那个分享到SNS网站的js写得并不够优雅，有许多冗余的地方。而我最近也在看javascript的设计模式，发现代理模式非常适合这种用来发送一组GET请求的情况，尤其是参数较少的时候。于是我就试着实现一个代理模式实现的版本。</p>
<h2 id="代理模式版本"><a href="#代理模式版本" class="headerlink" title="代理模式版本"></a>代理模式版本</h2><p>代理，顾名思义就是起到一个控制作用，实现的是和本体一样的接口方法，只是在发送请求的时候，进行参数的检查，或者是动态生成本体对象，然后向服务器发送请求。@myunlesser 兄指点我用js模板方法，这个方法高明了很多，因为每个SNS平台的url参数很不一样，如果每次都要检测这么多参数，将会非常麻烦。然而它们只是名字不同而已，我们可以赋予相同的标签如<code>{title}</code>，这样可以起到一个转接的作用。故而可以使用模板的方法，将匹配到的参数填充到url中。只需要在传入参数时指定参数对，然后用<code>fetchData</code>方法组装起来。</p>
<pre><code>var share2SNS = (function(){

    // 所有url集中在一处，而且表示方法很自由
    // 如sina的title是title+content 那么 使用${title} ${content}就能够将它们组合在一起，模板的威力可见一斑
        var urls = {
            sina: &quot;http://v.t.sina.com.cn/share/share.php?pic=${pics}&amp;title=${title} ${content}&amp;url=${url}&quot;,
            douban: &quot;http://www.douban.com/recommend/?url=${url}&amp;title=${title}&quot;
            // ...
        };

        function _openWindow(url, name, properties) {
            properties = (properties || &quot;&quot;);
            if (!window.open(url, name, properties)) {
                window.self.location.href = url;
            }
            return false;
        };

        // build the url 
        function _fetchData(platform, params){
            // fetch and replace
            var baseUrl = &apos;&apos;+urls[platform];
            var exp = /\$\{([^\{\}]+)\}/g;  // 括号里面的是分组
            var tmp = &apos;&apos;;
            // 对url的参数进行填充
            baseUrl = baseUrl.replace(exp, function(a, match){    
                // a is the whole match: ${abc}, match is the group:abc
                tmp = (params||{})[match]  || &apos;&apos;;    // get the proper params
                return encodeURIComponent(tmp);    
            });
            return baseUrl;
        }


        // return proxy
        return {
            // public 
            // params {title, content, url, pics} 唯一要知道的接口
            shareTo : function (platform, params){
                params[&apos;title&apos;] = params[&apos;title&apos;] || undefined, 
                params[&apos;content&apos;] = params[&apos;content&apos;] || undefined,
                params[&apos;url&apos;] = params[&apos;url&apos;] || undefined,
                params[&apos;pics&apos;] = params[&apos;pics&apos;] || undefined;

                var surl = _fetchData(platform, params);
                // console.log(surl);
                _openWindow(surl, platform);
            }
        };

})();
</code></pre><p>使用闭包的立即执行函数返回一个share2SNS的单体，外部只能通过shareTo方法调用：</p>
<pre><code>share2SNS.shareTo(&apos;sina&apos;, {
        title: &apos;IT小小鸟&apos;,
        url: &apos;http://bibodeng.com&apos;,
        content: &apos;我们的大学生活&apos;,
        pics: &apos;http://bibodeng.com/bibodeng/IT_birds/img/daoluan.png&apos;
});
</code></pre><p>可以说比较核心的方法就是js模板，我曾经想过让用户传入特定的参数对，例如<code>{href:&#39;http://bibodeng.com&#39;， pic: &#39;daoluan.png&#39;}</code> 等名字不一的键值对，然后通过join操作用&amp;连起来，但是那样会增大接口使用者的负担，而且没有起到解耦的作用。</p>
<p>一个程序员，要把复杂的事情变简单，这才是能力。又长又臭的代码，谁都可以写，但是优雅简洁的代码不是随便能写出来的。最近在学习《javascript设计模式》，里面的很多的东西都能够把事情变得简单，虽然一些模式本身就挺复杂的，但是掌握了其框架之后，写出来的代码明显优雅了很多。之前在实习的过程中碰到稍复杂的功能需求时感觉力不从心，很大程度就是不懂设计模式，看的过程种很多次都会发出这样的感慨，原来我不知不觉用过一些模式，而且有些模式用了之后整个app就简单了很多。继续攻书。</p>
<p>by bibodeng 2013-11-21</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/12/【转】精力的培养/" itemprop="url">
                  【转】精力的培养
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-12T11:22:37+08:00" content="2013-11-12">
              2013-11-12
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/12/【转】精力的培养/" class="leancloud_visitors" data-flag-title="【转】精力的培养">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="精力的培养"><a href="#精力的培养" class="headerlink" title="精力的培养"></a>精力的培养</h2><p>人的精力是颇为有限的。付出的过程比获取要长很多。做任何有益于自己的，成长性的事情都需要付出精力，这也要求人们有节制的使用这一无形资本——我认为这些显而易见的道理，越早想明白越好。</p>
<p>曾经有很长的一段时间我不明白为什么每当我参加一些人数众多，气氛热闹，互动频繁的活动时就会情绪低落，即使是参加大型同学聚会，面对大家欢快的讨论，我也多少有些拘谨。直到很久以后，我才明白这种性格特质叫：内向。而内向意味着个体在独处或面对有限的对象时精力充沛，而却对超出自我界限的对象则感到茫然无助，乃至疲惫不堪。</p>
<p>从那以后，我开始细心观察我身体中流淌着的无形力量：精力。进而不断的总结出关于精力的种种理论，并运用在生活中。一个很重要的前提即是，人们需要迫切的了解到他们适合做什么，不适合做什么，做什么精力耗费的极快，做什么有助于恢复精力。一旦了解到了这一点并合理分配调控，生活中的一些问题就可以得到解决。</p>
<p>有很多人喜欢抱怨“无聊”，我认为，“无聊”其实就是精力不济的一种标志。在这种状态下，你几乎不可能做任何“有意义”的事情——比如高效率的工作、学习。你只能做一些娱乐性较高看似放松的事情，比如吃零食，上网，看肥皂剧，玩游戏，等等。但在这一过程中，你内心的斗志实质上是被逐渐消磨的。随着时间逐渐拉长，你的精力愈发的懈怠，往往会坠入更深的无聊之中。</p>
<p>当然，现在你已经知道了，下次当你在一个百无聊赖的周末醒来，你不应该再用这些事情来帮助自己“放松”，从而在无聊的恶性循环中打转。但要根本性的了解该怎么做，你需要从头开始。</p>
<h3 id="适合做什么，不适合做什么"><a href="#适合做什么，不适合做什么" class="headerlink" title="适合做什么，不适合做什么"></a>适合做什么，不适合做什么</h3><p> 我有一个朋友，对她而言，阅读就是呼吸一般的存在，她在一切可能的时间都在看书（这个例子我已经举过好几次了，看过我别的文章的人都知道）。与此同时，与人闲聊、打发时间却是一件对她来说比较困难的事情。如果一段时间我和她的聊天都毫无主题，四处飞散，她就会不由自主的开始看书，上网，读文章……而且她也不太喜欢和人保持太过紧密的日常联系。很显然，对她而言，阅读是一件毫不费力的事情，甚至在每天长达数小时的专注阅读中，她的精力还在缓慢的增长。但与人日常交际上她就不是很热衷了，如果去到一个纯交际的场所，她还会觉得很烦躁。</p>
<p> 强求本能中的自己进行改变是一件吃力不讨好的事情。比如你明明是一个内向的人，非要强求自己去当大众的开心果；明明你是一个耿直的人，非要强求自己去说言不由衷的话；明明你有一个不错的爱好，却因为听闻别的爱好更“好”而去盲从——这些事情会极大的耗费你的精力，使得你的每一天在应付这些事情时就已疲惫不堪，怎么可能还有空闲去做别的事呢？所以，认清自己、阅读自己是做好这一切的第一步。</p>
<h3 id="训练自己的精力"><a href="#训练自己的精力" class="headerlink" title="训练自己的精力"></a>训练自己的精力</h3><p> 很显然，在那些让我们感到精力充沛和身心愉快的事情中，有一部分是颇为有建设性的，有些单纯只是为了娱乐。而在我们所能接受的范围以内，还存在着一些对自己颇为有益的事情。这个时候，需要的就是对自己的精力进行训练，以使得自己能在有意义的事情上保持更长的时间。</p>
<p>比如，我可以坚持连续严肃阅读——这件颇为有意义的事情——一个小时，而当一个小时之后，我就需要休息一小会儿或看些轻松的东西。而在一天的时间里，我的阅读上限在三个小时左右，当一天我将这么长的时间全部投入到阅读中时，再看什么我都脑中一片混沌，理解和记忆能力大为下降。很显然，虽然阅读这件事并不会明显耗费我的精力，但精力值中的确只有不多的一部分可以用在阅读这件事上。怎么办呢？这个时候就需要训练，不必训练到那位书痴读书如呼吸饮水般的程度，但要将这一上限大大提高，高到自己预料之外的程度。</p>
<p> 任何事情都需要训练，运动员要训练肌肉记忆，做学问的要训练神经突触，蓄养精力也是同样的道理。将做有意义的事情时的精力上限提高并不仅仅意味着下次再做这件事情的时候能坚持的时间更长，而是意味着即使你只做一定的时间，你的效率也会大为增强。那些书痴们的阅读效率和速度将远高于我们，这一结论是毫无疑问的。更为重要的是，随着精力的逐步增强，你在做一件事情时将会变得更为得心应手，并从中获取之前从未有过的愉悦感。（当你一次可以跑二十公里时，随意跑上个三公里只是在享受，而锻炼的效果却已经达到了）</p>
<p>在逐步的训练中，做某件事的精力值逐步提高了，而因为其趣味性也不断增强，你做其他相较之“不重要”的事情的时间也就缩短了。你的生活将变得更有意义，更加充实，对自我的成长帮助也越大。可能会有人觉得这种认识和方法太过功利化，为什么我们的生活不能惬意一点呢？我认为，在这个竞争极其激烈，每个人的综合素质已经变得越来越重要的时代，对自我的提高已经成了每天的必修课，这使得我们有必要为之调整我们的状态，并付出努力。同时，既然在坚持一段时间之后那些更有意义的事情也能带给我们快乐，又何乐而不为呢？</p>
<h3 id="分配你的精力"><a href="#分配你的精力" class="headerlink" title="分配你的精力"></a>分配你的精力</h3><p>人的精力终归是有限的，或者说，一天的时间终归是有限的，所以精力在不同的事情上必然要有所分配。于此同时，不管我们如何努力，生活中必然还是有一些事情让我们感到为难，违背了自己的本性，或者难以被训练，但却仍然需要做，还有一些事情我们明知道很损耗精力，但还是很愿意做。这时候分配就是一件重要的事情。</p>
<p> 如果你一大早就抢着把乐意做的事情做完了，而把最难完成的事情留到最后，那每天回到家时，你必然感到很疲惫，很倦怠。加之很多人又次错误的方法“放松”自己，再延长上床的时间，周而复始，很多人的生活呈现的实际上是一个下滑的曲线。而不幸的是，大多数人进入的实际上就是这样一种状态。</p>
<p>很显然，为了做那些我们需要耗费很大精力去完成的事情——比如工作——我们需要做充足的准备，留出足够的空档，并在其后对自己进行恢复。生活中总有很多事情让人感到崩溃，错误的策略将使这些事情演变为对自己的惩罚。</p>
<p>对于那些我必须要做但又让我感到痛苦的事情，我在做之前首先要鼓足自己的勇气。我会写一篇日记或什么其他让自己感到满足的文字（比如这篇），做一种很有规律很遵从规则能让自己从重复性中获得满足的练习（比如摹字），或者完成一件让我高兴的事情（比如看一集纪录片）。（注意，你需要做的所有事情都要让自己集中，而不是涣散。所以做娱乐性较强的事情是不行的。）在这些事情做完之后，我就开始埋头完成自己之前的计划，在这其中穿插进行着一些不影响我做事的小动作，比如听音乐，或看一篇文章，等等。待我完成时，我会感到疲惫，于是我会进而做一些让自己轻松但又不会让自己懈怠的事情。事实上，这一切都是轻而易举的完成的，不是刻意完成的。当一个过程为自己所熟悉的时候，一切就变成自然而然的事情了。</p>
<p> 再强调一遍，人与人之间是不同的。与其耗尽精力强迫自己，不如想点办法。有的人是工作狂，有的人——比如我——对工作往往燃不起热情。但工作是必须的，所以应对工作，我不断的寻找新的解决办法。直到我能够随时恢复自己的精力，或感觉工作不再是那么的痛苦。</p>
<p> 在除了学习和工作以外的其他时间，分配同样重要。如果你决定每天晚上回家的时间是自己的充电时间——看书，看电影，写作——那你就不可以让自己回家的时候已经感到难受和疲惫。你可以将事情挪到其他时间去做，可以在下班后先做一些让自己兴奋的事情，可以通过训练让自己在某些事情上如鱼得水……不管怎样，你总要找到办法让自己每天的生活更加均衡，而不是完成中间的某一个部分之后就做不了别的事情了。</p>
<h3 id="精力与体力的关系"><a href="#精力与体力的关系" class="headerlink" title="精力与体力的关系"></a>精力与体力的关系</h3><p> 我之所以将体力插进这里讲是因为体力是一个非常重要的存在，它可以说是精力存在的保证，乃至来源。一个病人——体力水平低于正常人的人——必然没有足够的精力来做任何事情。一个身体孱弱坐公交都会晕车的人，自然也没有足够的体力来保证自己发挥精力的作用。体力是一个人健康程度的象征，如果不够健康的话，自然会常受各种因素影响，没有办法把注意力集中到做有益的事情上去。当然，体力的重要性还不限于此。体力与精力是两种有弹性的魔力，如果能正确的运用这两者的力量，将会带来事半功倍的效果。</p>
<p> 很久以前我听过一个故事，讲一个人每天上班前都会进行半个小时的有氧训练，之后就能精力充沛的工作一整天。当我刚听到这个故事的时候是无法相信的，如果那时我也在工作前有氧运动半小时，整天我都会昏昏欲睡。当然，这就是一个进入了良性循环的人和一个刚刚开始循环的人的差别。</p>
<p>体力和精力都是一种可快速恢复的，弹性十足且通过训练可以显著提高的能量，尤其对于那些已经进行过训练的人而言。而当人因体育锻炼而精神焕发的时候，他的精力也随之反弹，而且这一过程经常性并不随着体力值的降低而呈正相关。你是不是有过这样一种体验：有时候你经过一天的奔波，体力运动，你反而感到精力旺盛，异常兴奋，甚至不能快速睡着。也许这种特例并不能说明体力值降低时人们的精力甚至能随之增长，但它也说明了运动的重要性。</p>
<p>显而易见的是，如果你一整天甚至更长的时间都待在家里，那你恐怕根本没法保持精力旺盛。</p>
<h3 id="保护精力不受损害"><a href="#保护精力不受损害" class="headerlink" title="保护精力不受损害"></a>保护精力不受损害</h3><p> 既然精力是如此重要并容易流失的一项无形资产，那么保护它则显而易见是一件重要的事情。现代社会节奏更快，强度更高，各种各样的事物和信息散落在各处，处处都在损害着精力。现在还没有太好的办法能归纳所有规避的方法，但我想以下的几点是显而易见的：</p>
<pre><code>1. 避免关注于己无关 /没有意义的事情。
</code></pre><p>有太多的人每天把注意力放在与自己完全无关的事情上，以此消磨自己的意志、精力和时间，原因只是因为他们很“无聊”。我不得不说这是一种恶劣的恶性循环。“无聊”是因为精力不济，而消磨时光的方式则带来自己更大层面上的损失：精力更加衰弱，精神懈怠，时间消耗。最后呢？他们真的能获得什么快乐吗？事实上是没有的。而且随着关注没有意义的新闻和事件带来的后续效应则经常性更加能伤害人。争论、怒气、不切实际的想法……除了这些以外，我很难看到这种关注带来的良性后果。如果有一部分人实在觉得每天关注些杂文段子能让自己感到娱乐，那如同我上文说到的那样，请注意良好的分配。</p>
<pre><code>2. 避免情绪的波动。
</code></pre><p>在我所知道的所有事情中，没有什么比强烈的情绪更能直接损耗一个人的精力。如果是强烈的快乐和兴奋还好，但如果是强烈的负面情绪，则会直接让一个人的精力陷入瘫痪。对于有些悲伤、痛苦和焦虑来说，避免是一件不可能的事情，但对于其他的部分，则考验着一个人的应对能力。有些类似的情绪还来源于自己，如果事实如此，那我们就需要好好考虑自己生活的策略了。</p>
<pre><code>3. 保持生活的平衡。
</code></pre><p>保持生活的平衡包括两部分，身体的平衡和心理的平衡。身体的平衡要求人们对自己的摄入、睡眠、运动保持掌控，对需要身体的任何情况应对自如。心理平衡则是同理，它是在“避免情绪波动”之上的一个范畴。这是一个很玄乎的状态，很难用文字表达出来。但当你处于这种状态时，则会时常感觉到平和、富足，而如果这种状态鲜有出现，则应该努力往这个方向靠拢。</p>
<pre><code>4. 不要在精力充沛的时候做一些损害精力的事情。
</code></pre><p>感到自己现在精力充沛，状态良好？这是一个好开头，但也可能仍然指向一个不佳的结尾。也许你没必要强迫自己非得立即做出什么了不起的事情来，但至少应该抓住这个好机会更进一步。记住，错误的放松方式是一种恶性循环，你会在不知不觉之中毁掉自己良好的状态和之前的努力。</p>
<h3 id="获取精力"><a href="#获取精力" class="headerlink" title="获取精力"></a>获取精力</h3><p>获取精力其实是和保护精力不受损害对应的概念，但它更侧重于我们要去做什么，而不是不去做什么。我认为以下几点是通过实践表明非常有效且值得分享的：</p>
<pre><code>1. 保持规律而充足的睡眠：
</code></pre><p>保持规律而充足的睡眠是如此的重要，重要到那些即使在生活其他方面一团糟的人经过睡眠的修复，也能快速的恢复到一个不错的状态。我有一位友人每天晚上都比前一天睡的晚一点，直至早晨睡觉晚上起床，再到中午睡觉午夜起床，最后又在一段很短的时间里变成了晚上睡觉早上起床……我一直认为她的作息是根本无药可救的，这一糟糕透顶的生活方式也给她带来了很大的伤害。譬如她糟糕的健康状况，美丽的妆容下晦暗的皮肤，暴躁的情绪和无穷无尽的纠结。即使她每天保持正常的状态比普通人要少很多，但经过一个漫长而深度的睡眠，她还是能很快的恢复到正常的状态下，并在那种状态下做一些自己喜欢做的事情，由此充分可见睡眠的重要作用。你应该也有在痛苦的夜晚睡去，经过长时间睡眠之后感觉好多了的经历。所以，请保持足够的、规律的睡眠，并不要找任何理由。虽然总有特殊情况，但可以肯定的是，大多数人晚睡的原因都不是什么正经的事儿，尤其是长期作息不规律的往往更是如此。将注意力集中在没有必要的事情上让人疲惫，睡前刷新网页，玩手机更是会直接损害睡眠质量……何必呢？看看书，保持沉静，安稳睡去，你的七到八个小时睡眠时间绝对不会在白天辜负你。</p>
<p>至于睡眠时间，最好的一种莫过于每天早晨在一个准确的时间起床，并长期坚持，方法在 <a href="http://www.douban.com/group/topic/10838192/" target="_blank" rel="noopener">这里</a></p>
<pre><code>2. 培养正确的爱好：
</code></pre><p>很遗憾，即使完全不想摆出一副“政治正确”的模样，但是事实就是如此：有些爱好就是比其他爱好要更好，比如阅读、观影、写作、摄影、画画，等等。这些爱好会让你感到开心，愉悦，幸福，满足，起到一些其他爱好无法满足的作用。人生出来的时候绝大多数都是大俗人，除了真正的天才，没有人天生就喜欢这些事情，很多是后天熏陶成的，甚至逼成的。当大众都知道这类爱好更好且更有意义的时候，我想需要的就是努力靠近，努力学习。有很多人在懈怠下来的时候第一想要去做的就是一种事实上没有多大真正趣味也不会带来多好结果的事情，与其做这些带来不那么好的结果，不如培养自己去喜爱更有价值的爱好。</p>
<p> 当然，这个里面有一点是需要强调的，有些看起来并不怎么有意义的爱好会因人而异产生完全不同的效果。如果你做了而使自己获得了真正的放松——比如狂欢之后感到情绪被宣泄（换到我只会感觉到空虚）——那你当然可以那么做。这一点归根结底还是要弄清自己真正适合做的是什么。</p>
<pre><code>3. 保持活动
</code></pre><p>我已经在体力和精力这一节谈到了这一点，但我在这里要进一步的强调。也许你真的找到了一百条不去专门做锻炼的理由（像我一样），那至少保持运动，不要让自己待在同一个地方。我每天上下班时一共要在路上走一个小时，经常外出参加活动或自己跑去什么地方转转，如果正好穿着运动鞋，我偶尔也随便跑一跑。虽然和那些动辄万米的资深跑友无法相比，但我的确也因此获取了更多做事的精力。谨记：生命是一种流动中的形式，一个不动的人是很难有活力的。即使以坐着写作为生的作家，也普遍都有外出散步的习惯。呆在一间小屋子里人能产生什么精神呢？除了独自徒生闷气以外。</p>
<p>曾经我也在我所描述的那种恶性循环中度过一天又一天，在各种毫无意义的事情上虚度光阴，浪费青春年华中的好时光而找找不到出路。直到我细心观察自己生活中的细节并从其中找出规律找出方法并在漫长的时间里坚持实践，才逐渐把握了生活的节奏。随着工作节奏的不断加快，各种新情况的出现，自我要求的迅速提高，我不断修正之前想法的错误，提出新理论以解决现实困难。正是在这种思索当中，思维得以飞越，理念得以宽广，意志得以坚恒。降低重心，集中意念，生活才可以简单而富足，无论你最终向往的是哪一层面的成功，这一领域的修行都能引你走到更远。</p>
<p>要知道，我们所有人都会老去，而我们中的几乎所有人都会比自己想像之中更早的老去，而老去时最常见的语言莫过于“精力有限”，“心有余而力不足”。等到这一能量无可救药离我们远去的时候，我们应该有让自己骄傲的珍惜。到时候你才不会后悔的说，当我在还有机会发挥潜能的时候，却让财富从我的生命中偷偷流走。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/09/latex生成各种格式电子书/" itemprop="url">
                  latex生成各种格式电子书
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-09T23:36:29+08:00" content="2013-11-09">
              2013-11-09
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/09/latex生成各种格式电子书/" class="leancloud_visitors" data-flag-title="latex生成各种格式电子书">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用latex源码生成各种格式电子书"><a href="#使用latex源码生成各种格式电子书" class="headerlink" title="使用latex源码生成各种格式电子书"></a>使用latex源码生成各种格式电子书</h1><p>by bibodeng 2013-11-09</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了让电子书能够在更多的平台上被阅读，那么则需要生成各种版本的电子书，这个过程真的有点蛋疼，但是通过各种非常有用的工具，干起来也非常快。下面主页记录一下常用的格式的生成：</p>
<pre><code>PDF，mobi， epub， html
</code></pre><p>其中PDF是最容易的，latex编译默认就输出PDF，所以我们很容易获得。而且上篇已经提及了如何生成6吋版的PDF电子书。所以下面着重讲一下其它三种格式的生成。</p>
<h2 id="epub"><a href="#epub" class="headerlink" title="epub"></a>epub</h2><p>epub格式是一种在苹果手机，平板上使用的通用格式，目前kindle还不支持，但是有些kindle的系统——如多看，已经支持epub格式的电子书了。在ubuntu下，可以使用pandoc这个工具，从latex文件直接生成epub格式电子书。</p>
<p>首先，我们要安装pandoc：</p>
<pre><code>sudo apt-get install pandoc
</code></pre><p>这样就安装好了。它的详细使用方法见<a href="http://johnmacfarlane.net/pandoc/epub.html" target="_blank" rel="noopener">这里</a>。我们直接使用pandoc命令转换格式：</p>
<pre><code>pandoc book.tex -o book.epub
</code></pre><p>可以看到立马生成了一个book.epub文件，将该书籍导入到calibre里面查看，可以看到转换的格式还行,稍微有一点瑕疵，大体上还是ok的。</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/279d39080390d5733af232089be3a0082013110907505713841.png" alt="epub版"></p>
<h2 id="mobi"><a href="#mobi" class="headerlink" title="mobi"></a>mobi</h2><p>mobi格式可以使用calibre直接从epub格式进行转换，安装完该软件后，直接对文件进行转换。等待一段时间，等其转换完成，打开发现mobi格式和epub几乎一样。</p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><h3 id="tex2page"><a href="#tex2page" class="headerlink" title="tex2page"></a>tex2page</h3><p>要生成html有许多工具，但是我们先介绍一种——tex2page，这里有一份王垠写的<a href="http://docs.huihoo.com/homepage/shredderyin/tex2page/intro.html" target="_blank" rel="noopener">教程</a>。</p>
<pre><code>tex2page book.tex
</code></pre><p>一般是可以编译成功的。如果在文档目录下新建一个和tex文档同名的.hdir文件，里面添加一行</p>
<pre><code>pages
</code></pre><p>则会在生成网页的同时能够把文件都放在pages下面，而不会在当前目录搞乱你的文档。</p>
<h3 id="tex4ht"><a href="#tex4ht" class="headerlink" title="tex4ht"></a>tex4ht</h3><p>还有一种办法是安装一个tex4ht，然后使用htlatex命令来转换。</p>
<pre><code>sudo apt-get install tex4ht
htlatex mydocument.tex 
</code></pre><p>这样会生成一个html文件。</p>
<h3 id="pandoc"><a href="#pandoc" class="headerlink" title="pandoc"></a>pandoc</h3><p>pandoc真的是一个神器啊，可以转换各种格式，这里有个<a href="http://johnmacfarlane.net/pandoc/demos.html" target="_blank" rel="noopener">示例</a>。</p>
<pre><code>pandoc -s -S --toc -c book.css book.tex  -o book.html
</code></pre><p>可以使用自定义的样式为生成的html进行排版。这样的效果会好一点：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/61661a8b55f13cc8bf9de521300735352013110915351330487.png" alt="IT小小鸟网页版"></p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/09/xelatex在文档处理中的使用/" itemprop="url">
                  xelatex在文档处理中的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-09T13:18:02+08:00" content="2013-11-09">
              2013-11-09
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/09/xelatex在文档处理中的使用/" class="leancloud_visitors" data-flag-title="xelatex在文档处理中的使用">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="xelatex在文档处理中的使用"><a href="#xelatex在文档处理中的使用" class="headerlink" title="xelatex在文档处理中的使用"></a>xelatex在文档处理中的使用</h1><p>by bibodeng 2013-11-09</p>
<h2 id="latex和pdflatex的问题"><a href="#latex和pdflatex的问题" class="headerlink" title="latex和pdflatex的问题"></a>latex和pdflatex的问题</h2><p>使用latex来直接编译，在有<code>\tableofcontent</code>的情况下会出现一些怪异的<code>unicode char \u8之</code>这样的错误，使得目录不完整。其原因是使用的<code>CJKutf8</code>的宏包所包含的utf8字符是不完整的，故而有些中文字符支持不完整。但是诡异的是同一个字符，在某些地方是ok的，在另外一些地方就是不行，可能是第一次编译输出的时候出错。如下的代码为<code>latex</code>文档：</p>
<pre><code>\documentclass[12pt,oneside]{book}
\usepackage{CJKutf8}
\usepackage[utf8]{inputenc}
\usepackage[titletoc]{appendix}
\usepackage{indentfirst}  % first paragraph indent
\setlength{\parindent}{2em}
\pagestyle{plain} % set the footer simple ,only a page number headings

\begin{document}

\begin{CJK*}{UTF8}{gkai} % gkai gbsn

\protect\setcounter{tocdepth}{1}
\tableofcontents  % 目录，二次编译

\section{中国} % 含有中文字符，在生成tableofcontent的时候可能出错
\begin{verbatim}
我爱你中国   
\end{verbatim}

\end{CJK*}
\end{document}
</code></pre><p>将会产生如下的错误：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/ba66d70c572c38dc44f202b3b8752f812013110904382232028.png" alt="unicode没设置报错"></p>
<p>尝试过在<code>\end{CJK*}</code>之前以及文档结尾加<code>\newpage</code>,都没有效果，在<code>stack exchange</code>也没有找到合适的答案。后来发现<code>texlive</code>可以解决这个问题。而需要安装<code>texlive</code>工具包，然后使用这个新的发行版的引擎来编译文档，所以文档需要重写了。</p>
<h2 id="安装和使用texlive"><a href="#安装和使用texlive" class="headerlink" title="安装和使用texlive"></a>安装和使用texlive</h2><p>要安装texlive，必须要有安装的介质，所以需要下载文件等，然后予以安装，这里有一个教程可供<a href="http://seisman.info/texlive-2013-under-linux.html" target="_blank" rel="noopener">参考</a>。中文支持可以暂时不理，到后面我们会使用<code>ubuntu</code>系统自带的中文字体做编译。</p>
<p>安装好之后，就让我们看看其文档结构：</p>
<pre><code>\documentclass[12pt,a4paper]{article}
\usepackage{fontspec,xunicode,xltxtra}
\usepackage{titlesec}
\usepackage[top=1in,bottom=1in,left=1.25in,right=1.25in]{geometry}

\titleformat{\section}{\Large\hei}{\thesection}{1em}{}

\XeTeXlinebreaklocale &quot;zh&quot;
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt

\newfontfamily\hei{WenQuanYi Micro Hei}  % 使用系统的中文字体
\setmainfont{AR PL UKai CN}              % 这3行定义文档字体，本行正文
\setmonofont{WenQuanYi Micro Hei}        % 标题等

\begin{document}

\title{\hei XeTeX使用小结}
\author{\hei 小明}
\date{\hei 2009年6月21日}

\maketitle

\section{简介}
以前使用CJK进行中文的排版，需要自己生成字体库，近日，出现了XeTeX，可以比较好的解决中文字体问题，不需要额外生成LaTeX字体库，直接使用计算机系统里的字体。

\section{字体列表}
本文使用了大量本机自带的字体。

\centering
你好！

\end{document}
</code></pre><p>可以看到我们的文档中使用了自己系统中的字体，而不是使用各种各样的字体宏包。我们可以使用命令：</p>
<pre><code>fc-list :lang=zh-cn
</code></pre><p>来查看系统中都有什么中文字体：<br><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/4901815145f36d1d475207eef5bb44b52013110904593212245.png" alt="fc-list命令结果"></p>
<p>我们要使用的是字体的名字，例如<code>WenQuanYi Micro Hei</code>和<code>AR PL UKai CN</code>,也就是两个冒号之间的那个名字。这样我们果然可以编译出漂亮的使用系统字体的文档了。再把之前latex的文档中的<code>preamble</code>（声明usepackage的地方）部分中的代码拷贝过来放到对应的<code>\begin{document}</code>之前就可以了。然后我们就可以运行 <code>xelatex article.tex</code>来编译文档了，编译后可以看到生成的pdf文件，不会再出现之前的目录错误了。</p>
<pre><code>% preamble示意
\documentclass{class}
… preamble部分
\begin{document}
… 正文内容 …
\end{document}
</code></pre><p>目录正确显示效果:</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/e711308f47cbe55a01abd951d4aa3e682013110905133112413.png" alt="目录ok了"></p>
<h2 id="使用latex生成各种尺寸的pdf"><a href="#使用latex生成各种尺寸的pdf" class="headerlink" title="使用latex生成各种尺寸的pdf"></a>使用latex生成各种尺寸的pdf</h2><p>假如我们要生成适合<code>kindle</code>阅读的PDF 6吋版，那么在latex中将非常地方便。因为只需要在<code>preamble</code>中加入如下代码就ok了：</p>
<pre><code>\usepackage[paperwidth=9cm, paperheight=12cm, top=0.1cm, bottom=0.2cm, left=0.2cm, right=0.2cm]{geometry}
\special{papersize=9cm,12cm}
</code></pre><p>而且这个尺寸可以随意更改。所以可以针对特定的屏幕大小进行编译。我编译的6吋版本效果如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/26bbead36d401f3407f6de55cac89ad42013110905101210145.png" alt="pdf六吋版本效果"> </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>折腾那么久<code>tex</code>,现在才发现一个好的发行版有多么重要，这样让我们做的工作的轻松起来，而不是捉襟见肘地去解决那些对中文的支持问题。而我们也将使用这个工具，继续我们《IT小小鸟外传》的编写，竭尽全力地制作出良好阅读体验的电子书，并且生成各种版本以支持更多的设备。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/03/常用latex代码块/" itemprop="url">
                  常用latex代码块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-03T16:27:17+08:00" content="2013-11-03">
              2013-11-03
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/03/常用latex代码块/" class="leancloud_visitors" data-flag-title="常用latex代码块">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#常用latex代码块</p>
<p>by bibodeng 2013-11-3</p>
<h2 id="为啥搞latex"><a href="#为啥搞latex" class="headerlink" title="为啥搞latex"></a>为啥搞latex</h2><p>其实接触<code>latex</code>也有些日子了，本来是一直打算用它来排版我们自己的简历，论文，还有我们业余写的电子书。最近和思愿在折腾这个东西，故而觉得有必要整理出一篇常用的latex代码块出来，然后结合我们的需要发挥。</p>
<p>宿舍一个哥们总是说我折腾，linux，latex，Qt，折腾的东西真的不少。我自己也问我自己是不是浪费了太多时间在这些不必要的折腾上，后来意识到任何东西都有好处也有不好，就看我们用的人的心态，用的方式了。latex如果用得好，将来写毕业论文的时候必定是让老师眼前一亮，不排除这有点装逼嫌疑，但是我是喜欢酷的，喜欢与众不同。即使是排版，我也觉得用代码什么排出来的会非常漂亮。</p>
<h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><p>有了下面的一些常用代码，我们很容易就解决排版中的一些基本问题，除此之外，建议阅读《一份不太简短的latex说明》。<a href="http://wenku.baidu.com/view/754ab741a8956bec0975e3b2.html" target="_blank" rel="noopener">百度</a>和<a href="http://ishare.iask.sina.com.cn/download/explain.php?fileid=18921996" target="_blank" rel="noopener">新浪</a>提供下载。</p>
<h3 id="嵌入代码块"><a href="#嵌入代码块" class="headerlink" title="嵌入代码块"></a>嵌入代码块</h3><p>如果文档或书籍中带有代码，那么我们常常要使得代码缩进，并且着色。</p>
<pre><code>%　先在文档声明区加入必需的包
\documentclass[11pt,oneside]{book}
\usepackage{CJKutf8}
\usepackage[utf8]{inputenc}
... % 下面这些是重点
\usepackage{listings}
\usepackage{xcolor}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}
</code></pre><p>然后我们就可以直接在一个章节里面插入代码了，以C++为例，也可以使用Java等其它语言：</p>
<pre><code>\begin{lstlisting}[language=C++,caption={C++ version}]
void main()
{
    printf(&quot;hello world&quot;);
}
\end{lstlisting}
</code></pre><p>上面这段代码向文中嵌入代码。可以看到关键字被染色了，如果有注释的话，还会被染成红色。</p>
<p><img src="http://bibodeng.com/content/plugins/kl_album/upload/201311/96a79f2b7967bfd2a1b6e7766520f9972013110307335829475.png" alt="代码示例"></p>
<h3 id="嵌入图片"><a href="#嵌入图片" class="headerlink" title="嵌入图片"></a>嵌入图片</h3><p>我们的文档常常有一些图片要嵌入，以达到图文并茂的效果。特别是在一些论文中，以图形作为说明。latex具有强大的图形绘制能力，但是我们这里只介绍如何嵌入外来图片。</p>
<pre><code>% 同样是先包含包
\usepackage{subfig}
\usepackage{wrapfig}    % 图文包围的时候用到
\usepackage{graphicx}
</code></pre><p>下面在上下文中嵌入一张图片：</p>
<pre><code>% 省略上文（此为注释）
\begin{figure}[!htp]
\centering
\includegraphics[angle=10,
width=0.7\textwidth]{pic/junxun.jpg}
\caption{三连南僧激动地和对面二连拉歌}
\end{figure}
% 省略下文
</code></pre><p>效果如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/f3333114456e25b0240818f67c08f3ce2013110307432017124.png" alt="插入图片"></p>
<p><code>htp</code>是为了让图片不要落在边界，顶部等特殊地方，而是在正文中。<code>centering</code>死让图片居中，然后是最核心的<code>includegraphics</code>将图片包含进来，并且制定角度为10°，宽度为页面总宽度的70%，<code>caption</code>即为标题。然后注意要闭合嵌入的<code>figure</code>元素。</p>
<h3 id="嵌入文字包围的图片"><a href="#嵌入文字包围的图片" class="headerlink" title="嵌入文字包围的图片"></a>嵌入文字包围的图片</h3><p>那如果要嵌入文字包围的图片，该怎么弄呢？我们要的效果是只在图片存在的地方，文字绕道，但是过了这个位置，则包围了文字。先看别人的<a href="http://www.ctex.org/documents/latex/graphics/node115.html" target="_blank" rel="noopener">经典效果</a>：</p>
<pre><code>\begin{wrapfigure}{r}{4.5cm}
\includegraphics[width=4cm, clip]{pic/face.jpg}
\end{wrapfigure} 
\mbox{}我们的爱情，就像春天盛开的鲜花，无比热情。每当我见到你，就沉醉于其中，快乐无比。我就像那在浅浅柔波中的水草，享受着康桥的水的轻抚。
</code></pre><p>效果如下：<br><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/e46b2f87875b8674726d66673259641d2013110308225412500.png" alt="图文混排"><br>如果没有<code>\mbox{}</code>那么就会出现文字出现在图片上的效果。<code>wrapfigure</code>的效果就像是二者可以叠加，也可以互相排斥开来。</p>
<p>更多的latex代码块，还是看教程比较靠谱吧（比如那看起来很高级的数学公式）。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/03/事件代理实现/" itemprop="url">
                  事件代理实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-03T11:26:49+08:00" content="2013-11-03">
              2013-11-03
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/03/事件代理实现/" class="leancloud_visitors" data-flag-title="事件代理实现">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#事件代理实现</p>
<p>by bibodeng 2013-10-29</p>
<h2 id="事件代理的原理"><a href="#事件代理的原理" class="headerlink" title="事件代理的原理"></a>事件代理的原理</h2><p>所谓事件代理，就是说让另外一个元素，一般是父元素来绑定事件，然后处理的是子元素被点击后的逻辑。这样的目的是减少绑定事件的消耗，因为往往一个父元素下有很多个相同的子元素，它们所绑定的事件也是一样的，故而可以将这个消耗给转移到同一个绑定中，既提升效率，也使得程序变得优雅。我在博客园找到一篇事件代理的<a href="http://www.cnblogs.com/bluedream2009/archive/2010/08/23/1806865.html" target="_blank" rel="noopener">文章</a>，可惜没有注释，而且对于事件代理的原理还需要深入学习一下。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现的思路是，对document下的事件进行监听，从事件的源开始向父元素迭代，如果匹配了我们传入的属性值，那么事件将在这个元素进行触发。其本质就是，在根元素绑定事件，传入能够匹配子元素的处理函数。</p>
<pre><code>// 代理事件
// 选择属性，事件类型， 事件处理函数
function delegateEvent(props, type, handler){

    // 能够匹配子元素的根元素事件处理函数
    var fn = function(e){
        e = e || window.e;
        var target = e.target || e.srcElement,    // 获取事件目标
            parent = target,
            p, prop,
            matches = false;


        do{
            matches = false;

            // 对prop的属性进行检查，看是否匹配传入的props参数
            for (p in props){
                if (!props.hasOwnProperty || props.hasOwnProperty(p)){
                    prop = props[p]; // 取得属性值
                    // 若是正则表达式，则使用test，若不是则直接判断是否相等
                    matches = prop.test ? prop.test(parent[p]) : prop === parent[p];
                }
            }
            // 若匹配，则调用handler
            if (matches){
                return handler.call(parent, e);
            }

        }while(parent = parent.parentNode); // 是父元素，一直代理到最顶层 

        return true;
    },

    doc = document;
    // 作对文档的绑定，全部时间代理到docmuent下
    if (doc.addEventListener){    
        doc.addEventListener(type, fn, false);    // 将该代理的事件处理作为一个回调函数传入
    }else{
        if (doc.attachEvent){                    // IE
            doc.attachEvent(&apos;on&apos;+ type, fn);
        } else{                                    // 不支持attach
            var originHandler = doc[&apos;on&apos; + type];    // 原始的处理函数 onload等
            doc[&apos;on&apos; + type] = function(e){
                originHandler.call(this, e);    // 不能覆盖，需要先执行一次原始的处理函数
                fn(e);                            // 再调用代理处理，这样就绑定到doc上了
            };
        }
    }
}; // delegateEvent

// 调用例子
delegateEvent({nodeName:/^li$/i, id:&quot;item_list&quot;}, &apos;click&apos;, function(){
    alert(this.id);
});
</code></pre><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>出于上面的程序的启发，我们可以写出一个自己的程序，能够针对某一个父元素，代理其子元素的事件。jQuery本身就能够使用形如：<code>$(parent).delegate(&#39;chlidTag&#39;, &#39;type&#39;, function(){})</code>的方式进行代理事件。故而，我们也可以写一个程序进行模拟：</p>
<pre><code>&lt;body&gt;
    &lt;ul id=&quot;item_list&quot;&gt;
        &lt;li id= &quot;1&quot;&gt;1&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;2&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;3&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;4&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;5&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;6&lt;/li&gt;
        &lt;li id= &quot;7&quot;&gt;7&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre><p>这是html文档，下面是改进后的javascript：</p>
<pre><code>// 代理目标， 被代理选择器， 事件类型， 事件处理函数
function delegate(deleTarget, props, type, handler){

    // 封装后的处理函数
    var fn = function(e){
        e = e || window.e;
        var target = e.target || e.srcElement,    // 获取事件目标
            parent = target,
            p, prop,
            matches = false;

        //console.log(&quot;target&quot;: target);

        do{
            matches = false;

            // 对prop的属性进行检查，看是否匹配传入的props参数
            for (p in props){
                if (!props.hasOwnProperty || props.hasOwnProperty(p)){
                    prop = props[p]; // 取得属性值
                    // 若是正则表达式，则使用test，若不是则直接判断是否相等
                    matches = prop.test ? prop.test(parent[p]) : prop === parent[p];
                    //console.log(prop, matches, parent);
                }
            }
            // 若匹配，则调用handler
            if (matches){
                return handler.call(parent, e);
            }

        }while(parent = parent.parentNode); // 是父元素，一直代理到最顶层 

        return true;
    };

    // 绑定事件
    try{
        if (deleTarget)
        {
            console.log(deleTarget);
            // 对target进行事件绑定
            if (deleTarget.addEventListener){    
                deleTarget.addEventListener(type, fn, false);    // 将该代理的事件处理作为一个回调函数传入
            }else{
                if (deleTarget.attachEvent){                    // IE
                    deleTarget.attachEvent(&apos;on&apos;+ type, fn);
                } else{                                    // 不支持attach
                    var originHandler = deleTarget[&apos;on&apos; + type];    // 原始的处理函数 onload等
                    deleTarget[&apos;on&apos; + type] = function(e){
                        originHandler.call(this, e);    // 不能覆盖，需要先执行一次原始的处理函数
                        fn(e);                            // 再调用代理处理，这样就绑定到doc上了
                    };
                }
            }
        }
        else
        {
            throw {
                &apos;msg&apos;: &apos;the object is null&apos;
            }
        }
    }
    catch(e)
    {
        alert(e.msg);
    }


};

delegate(document.getElementById(&apos;item_list&apos;), {nodeName: /^li$/i}, &apos;click&apos;, function(){
    alert(this.id);
});
</code></pre><p>当我点击其中子元素时， 可以看到console.log显示的父元素正是item_list，而事件弹出的是子元素的id属性。实验结果如下图：<br><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/6cc9d4da53f20d06793cac47445c529e2013110303240430568.png" alt="代理测试效果"></p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/27/初识NoSQL/" itemprop="url">
                  初识NoSQL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-27T17:35:23+08:00" content="2013-10-27">
              2013-10-27
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/27/初识NoSQL/" class="leancloud_visitors" data-flag-title="初识NoSQL">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#初识NoSQL<br>by bibodeng 2013-10-27</p>
<h2 id="Not-only-SQL"><a href="#Not-only-SQL" class="headerlink" title="Not only SQL"></a>Not only SQL</h2><p>之前就接触过NoSQL，但是从来没有再项目实践中使用过。故而，很有必要从入门之初就动手操练一下，就算不太熟练，也能知道其中精华一二。我告诫自己，要紧凑明确，对任何东西都有意识地围绕最核心的东西去发问，凡事问个为什么，不要浪费太多时间在不重要的踌躇中。我之前看过一点NoSQL，毕竟没有什么实战经验，所以忘得也快，现在复习一下。</p>
<p>现代互联应用网对于数据库的要求：</p>
<ol>
<li>低延迟的读写速度：应用快速地反应能极大地提升用户的满意度; </li>
<li>支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量; </li>
<li>大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理; </li>
<li>庞大运营成本的考量：IT经理们希望在硬件成本、软件成本和人力成本能够有大幅度地降低; </li>
</ol>
<p>关系型数据库的优势在于：</p>
<ol>
<li>事务支持 （如MySQL的 InnoDB引擎）</li>
<li>进行复杂查询 （join，几个表联合起来查询）</li>
<li>技术成熟 （oracle， MySQL， SQLServer）</li>
</ol>
<p>NoSQL是一种新型的数据库，和关系型数据库有所不同，在以下方面具有优势:</p>
<ol>
<li>适合分布式，简单的扩展：典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群; </li>
<li>快速的读写：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作; </li>
<li>低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本; </li>
</ol>
<p>以上几点来自互联网，到目前我还没有直观的感受。NoSQL有很多种类型，常见的有Memcached, Redis, MongoDB(和JS有很大渊源)等。</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/c7f3d4b3c551949a9f63c2dcc656294e2013102707103327065.png" alt="nosql类型"></p>
<p>键值存储类型的NoSQL数据库，主要是在内存中记录一些经常使用的数据，例如数据库的主键，这就就能够快速存取，而在内存中虽然快，但是存取不够可靠，有可能会丢失，造成数据的不一致性。故而，有一种策略就是当键值修改频率大过某个值的时候，就将缓存的数据给写到磁盘中去。Memcached也可以同MySQL搭配使用（互补），PHP有提供其驱动及接口，我们熟悉的SAE就是采用主从数据库+Memcached的架构。</p>
<p>面向文档的数据库，是将数据以文档的形式存储，其实是类似JSON的格式，也是键值对。</p>
<h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>使用散列表的方式存储键值对，全部存储在内存中，故而相当高速，可以很好地改善延迟。</p>
<p><strong>一致性散列技术</strong>：</p>
<p>如果有多台服务器，原理上是使用总数据量除以服务器台数取余来决定散列到哪个服务器，但是当有服务器加入进来时，这个计算到的余数会发生变化。如mod 4 变成 mod5,会有相当数据要重新散列。</p>
<p>而一致性散列将一个范围内的数据，散列到一个圆周上的各个服务器中。并且对于均衡负载，扩展集群，数据迁移等具有良好的支持。并且当有服务器发生故障时，影响的是一部分的数据，有服务器加入进来时，不会因为重新散列找不到数据了，而是只影响少量的数据（需从旧节点迁移到新节点），也即将原来范围内的一部分数据迁移就可以了。如下图所示：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/0053dd31c19d94a02d797b2f513fb733201310270816487506.png" alt="散列一致性"></p>
<p>那么具体它是怎么计算，让部分服务器4的数据散列到服务器5呢？</p>
<p>根据key算出hash值，选择第一个大于该hash值的虚节点server，系统维护了一个server list，每个server具有多个虚节点。也即它的数据不是由服务器数量决定放在哪里的，而是对一个更大的数进行散列，由服务器位置来决定的。</p>
<p><strong>缺陷</strong>：</p>
<p>一定要使用明确的查询条件，就像hash_table数据结构一样，所以不能像关系型一样用<code>LIKE</code>。</p>
<p><strong>启动</strong>：</p>
<pre><code>// 启动   后台运行  端口   用户名    链接数   内存限制
memcached -d -p 12345 -u uname -c 1024 -m 512 
</code></pre><p><strong>使用</strong>：</p>
<pre><code>// 设置键值对 键， 是否压缩， 过期时间戳， 大小
set &lt;key&gt; &lt;flag&gt; &lt;expires&gt; &lt;byte&gt;
&lt;value&gt; // 存储的值

// 获取值
get &lt;key&gt; // 返回key对于的value

// 清空
flush_all 
// flush后数据所占的内存并不会被释放，但会被标记为过期，是不能再被取得了
</code></pre><p><strong>编程语言中的使用</strong>：</p>
<p>请参考<a href="http://www.php.net/manual/zh/book.memcached.php" target="_blank" rel="noopener">PHP memcached手册</a></p>
<pre><code>$options = array( 
    &apos;servers&apos; =&gt; array(&apos;192.168.1.1:11211&apos;), //memcached 服务的地址、端口，可用多个数组元素表示多个 memcached 服务 
    &apos;debug&apos; =&gt; true,                         //是否打开 debug 
    &apos;compress_threshold&apos; =&gt; 10240,             //超过多少字节的数据时进行压缩 
    &apos;persistant&apos; =&gt; false                     //是否使用持久连接 
); 
// 创建 memcached 对象实例 
$mc = new memcached($options); 
// 设置此脚本使用的唯一标识符 
$key = &apos;mykey&apos;; 
// 往 memcached 中写入对象 
$mc-&gt;add($key, &apos;some random strings&apos;); 
// 取出该值
$val = $mc-&gt;get($key); 
// 替换已写入的对象数据值 
$mc-&gt;replace($key, array(&apos;some&apos;=&gt;&apos;haha&apos;, &apos;array&apos;=&gt;&apos;xxx&apos;)); 
// 删除一个值
$mc-&gt;delete($key); 
</code></pre><p>可见，在编程语言中，这样使用memcache数据库已经非常方便了，直接对键值进行存取删除。所以我们就可以在程序中将一些常用的值缓存起来，例如一个获取最新微博的查询，那么我们可以缓存这些微博，当有人刷的时候，就从缓存返回，将大大提升访问速度。</p>
<p>Redis和memcached有点类似，但是它可以进行永久性的键值存储，所以相对又更靠后一点。</p>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB是无需定义表结构的一种文档型数据库，和关系型一定要确定表的结构，存储各个字段有很大不同。MongoDB是以BSON（binary JSON）的方式来存储数据的，也是以键值的方式对应起来。多个文档可以组成一个集合（对应表），多个集合构成了数据库。    </p>
<p>但是MongoDB不支持JOIN查询以及事务处理。且不是实时写入磁盘，而是有一定的延时。</p>
<p>其MongoDB shell是数据库的管理工具，其脚本语言和JS类似。一些常用的操作可以参考<a href="http://www.cnblogs.com/archie2010/archive/2012/10/07/2712937.html" target="_blank" rel="noopener">例子</a>。以前我一直在担心，这样的键值对存在文档里面，其存取速度会不会很慢呢？它是取得JSON，转化为内存中的对象进行操作的么？</p>
<p>我看到了这样一段话：</p>
<blockquote>
<p>在使用场合下，千万级别的文档对象，近10G的数据，对有索引的ID的查询不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在让我惊讶。写入性能同样很令人满意。</p>
</blockquote>
<p>具体的测试例子，已经有哥们用号称亿级数据进行了<a href="http://www.cnblogs.com/lovecindywang/archive/2011/03/02/1969324.html" target="_blank" rel="noopener">测试</a>。</p>
<p>后续将会继续深入探索NoSQL数据库。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bitcoin-cash-logo.svg"
               alt="bibodeng" />
          <p class="site-author-name" itemprop="name">bibodeng</p>
          <p class="site-description motion-element" itemprop="description">区块链爱好者，互联网从业者</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">185</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/bibodeng" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/bibodeng" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/bibodeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifwallet.com" title="IFWallet" target="_blank">IFWallet</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifpass.cash" title="IFPassword" target="_blank">IFPassword</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bibodeng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("RrMSWOa8nuCnCCWn8TyPa7Od-gzGzoHsz", "8xnzit83sqv6vUEuXlsEWe0s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
